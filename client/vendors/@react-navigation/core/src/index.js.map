{
  "version": 3,
  "sources": ["../../../tmp/@react-navigation/core/src/BaseNavigationContainer.tsx", "../../../tmp/@react-navigation/core/src/checkDuplicateRouteNames.tsx", "../../../tmp/@react-navigation/core/src/checkSerializable.tsx", "../../../tmp/@react-navigation/core/src/createNavigationContainerRef.tsx", "../../../tmp/@react-navigation/core/src/EnsureSingleNavigator.tsx", "../../../tmp/@react-navigation/core/src/findFocusedRoute.tsx", "../../../tmp/@react-navigation/core/src/NavigationBuilderContext.tsx", "../../../tmp/@react-navigation/core/src/NavigationContainerRefContext.tsx", "../../../tmp/@react-navigation/core/src/NavigationContext.tsx", "../../../tmp/@react-navigation/core/src/NavigationRouteContext.tsx", "../../../tmp/@react-navigation/core/src/NavigationStateContext.tsx", "../../../tmp/@react-navigation/core/src/UnhandledActionContext.tsx", "../../../tmp/@react-navigation/core/src/useChildListeners.tsx", "../../../tmp/@react-navigation/core/src/useEventEmitter.tsx", "../../../tmp/@react-navigation/core/src/useKeyedChildListeners.tsx", "../../../tmp/@react-navigation/core/src/useOptionsGetters.tsx", "../../../tmp/@react-navigation/core/src/useScheduleUpdate.tsx", "../../../tmp/@react-navigation/core/src/useSyncState.tsx", "../../../tmp/@react-navigation/core/src/Group.tsx", "../../../tmp/@react-navigation/core/src/Screen.tsx", "../../../tmp/@react-navigation/core/src/createNavigatorFactory.tsx", "../../../tmp/@react-navigation/core/src/CurrentRenderContext.tsx", "../../../tmp/@react-navigation/core/src/getActionFromState.tsx", "../../../tmp/@react-navigation/core/src/useRouteCache.tsx", "../../../tmp/@react-navigation/core/src/getFocusedRouteNameFromRoute.tsx", "../../../tmp/@react-navigation/core/src/getPathFromState.tsx", "../../../tmp/@react-navigation/core/src/fromEntries.tsx", "../../../tmp/@react-navigation/core/src/validatePathConfig.tsx", "../../../tmp/@react-navigation/core/src/getStateFromPath.tsx", "../../../tmp/@react-navigation/core/src/NavigationHelpersContext.tsx", "../../../tmp/@react-navigation/core/src/types.tsx", "../../../tmp/@react-navigation/core/src/useFocusEffect.tsx", "../../../tmp/@react-navigation/core/src/useNavigation.tsx", "../../../tmp/@react-navigation/core/src/useIsFocused.tsx", "../../../tmp/@react-navigation/core/src/useNavigationBuilder.tsx", "../../../tmp/@react-navigation/core/src/isArrayEqual.tsx", "../../../tmp/@react-navigation/core/src/isRecordEqual.tsx", "../../../tmp/@react-navigation/core/src/useComponent.tsx", "../../../tmp/@react-navigation/core/src/useCurrentRender.tsx", "../../../tmp/@react-navigation/core/src/useDescriptors.tsx", "../../../tmp/@react-navigation/core/src/SceneView.tsx", "../../../tmp/@react-navigation/core/src/StaticContainer.tsx", "../../../tmp/@react-navigation/core/src/useNavigationCache.tsx", "../../../tmp/@react-navigation/core/src/useFocusedListenersChildrenAdapter.tsx", "../../../tmp/@react-navigation/core/src/useFocusEvents.tsx", "../../../tmp/@react-navigation/core/src/useNavigationHelpers.tsx", "../../../tmp/@react-navigation/core/src/useOnAction.tsx", "../../../tmp/@react-navigation/core/src/useOnPreventRemove.tsx", "../../../tmp/@react-navigation/core/src/useOnGetState.tsx", "../../../tmp/@react-navigation/core/src/useOnRouteFocus.tsx", "../../../tmp/@react-navigation/core/src/useRegisterNavigator.tsx", "../../../tmp/@react-navigation/core/src/useNavigationContainerRef.tsx", "../../../tmp/@react-navigation/core/src/useNavigationState.tsx", "../../../tmp/@react-navigation/core/src/useRoute.tsx", "../../../tmp/@react-navigation/core/src/index.tsx"],
  "sourcesContent": ["import { CommonActions, } from '@react-navigation/routers';\nimport * as React from 'react';\nimport checkDuplicateRouteNames from './checkDuplicateRouteNames';\nimport checkSerializable from './checkSerializable';\nimport { NOT_INITIALIZED_ERROR } from './createNavigationContainerRef';\nimport EnsureSingleNavigator from './EnsureSingleNavigator';\nimport findFocusedRoute from './findFocusedRoute';\nimport NavigationBuilderContext from './NavigationBuilderContext';\nimport NavigationContainerRefContext from './NavigationContainerRefContext';\nimport NavigationContext from './NavigationContext';\nimport NavigationRouteContext from './NavigationRouteContext';\nimport NavigationStateContext from './NavigationStateContext';\nimport UnhandledActionContext from './UnhandledActionContext';\nimport useChildListeners from './useChildListeners';\nimport useEventEmitter from './useEventEmitter';\nimport useKeyedChildListeners from './useKeyedChildListeners';\nimport useOptionsGetters from './useOptionsGetters';\nimport { ScheduleUpdateContext } from './useScheduleUpdate';\nimport useSyncState from './useSyncState';\nconst serializableWarnings = [];\nconst duplicateNameWarnings = [];\n/**\n * Remove `key` and `routeNames` from the state objects recursively to get partial state.\n *\n * @param state Initial state object.\n */\nconst getPartialState = (state) => {\n    if (state === undefined) {\n        return;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const { key, routeNames, ...partialState } = state;\n    return {\n        ...partialState,\n        stale: true,\n        routes: state.routes.map((route) => {\n            if (route.state === undefined) {\n                return route;\n            }\n            return { ...route, state: getPartialState(route.state) };\n        }),\n    };\n};\n/**\n * Container component which holds the navigation state.\n * This should be rendered at the root wrapping the whole app.\n *\n * @param props.initialState Initial state object for the navigation tree.\n * @param props.onStateChange Callback which is called with the latest navigation state when it changes.\n * @param props.children Child elements to render the content.\n * @param props.ref Ref object which refers to the navigation object containing helper methods.\n */\nconst BaseNavigationContainer = React.forwardRef(function BaseNavigationContainer({ initialState, onStateChange, onUnhandledAction, independent, children, }, ref) {\n    const parent = React.useContext(NavigationStateContext);\n    if (!parent.isDefault && !independent) {\n        throw new Error(\"Looks like you have nested a 'NavigationContainer' inside another. Normally you need only one container at the root of the app, so this was probably an error. If this was intentional, pass 'independent={true}' explicitly. Note that this will make the child navigators disconnected from the parent and you won't be able to navigate between them.\");\n    }\n    const [state, getState, setState, scheduleUpdate, flushUpdates] = useSyncState(() => getPartialState(initialState == null ? undefined : initialState));\n    const isFirstMountRef = React.useRef(true);\n    const navigatorKeyRef = React.useRef();\n    const getKey = React.useCallback(() => navigatorKeyRef.current, []);\n    const setKey = React.useCallback((key) => {\n        navigatorKeyRef.current = key;\n    }, []);\n    const { listeners, addListener } = useChildListeners();\n    const { keyedListeners, addKeyedListener } = useKeyedChildListeners();\n    const dispatch = React.useCallback((action) => {\n        if (listeners.focus[0] == null) {\n            console.error(NOT_INITIALIZED_ERROR);\n        }\n        else {\n            listeners.focus[0]((navigation) => navigation.dispatch(action));\n        }\n    }, [listeners.focus]);\n    const canGoBack = React.useCallback(() => {\n        if (listeners.focus[0] == null) {\n            return false;\n        }\n        const { result, handled } = listeners.focus[0]((navigation) => navigation.canGoBack());\n        if (handled) {\n            return result;\n        }\n        else {\n            return false;\n        }\n    }, [listeners.focus]);\n    const resetRoot = React.useCallback((state) => {\n        const target = state?.key ?? keyedListeners.getState.root?.().key;\n        if (target == null) {\n            console.error(NOT_INITIALIZED_ERROR);\n        }\n        else {\n            listeners.focus[0]((navigation) => navigation.dispatch({\n                ...CommonActions.reset(state),\n                target,\n            }));\n        }\n    }, [keyedListeners.getState, listeners.focus]);\n    const getRootState = React.useCallback(() => {\n        return keyedListeners.getState.root?.();\n    }, [keyedListeners.getState]);\n    const getCurrentRoute = React.useCallback(() => {\n        const state = getRootState();\n        if (state == null) {\n            return undefined;\n        }\n        const route = findFocusedRoute(state);\n        return route;\n    }, [getRootState]);\n    const emitter = useEventEmitter();\n    const { addOptionsGetter, getCurrentOptions } = useOptionsGetters({});\n    const navigation = React.useMemo(() => ({\n        ...Object.keys(CommonActions).reduce((acc, name) => {\n            acc[name] = (...args) => \n            // @ts-expect-error: this is ok\n            dispatch(CommonActions[name](...args));\n            return acc;\n        }, {}),\n        ...emitter.create('root'),\n        dispatch,\n        resetRoot,\n        isFocused: () => true,\n        canGoBack,\n        getParent: () => undefined,\n        getState: () => stateRef.current,\n        getRootState,\n        getCurrentRoute,\n        getCurrentOptions,\n        isReady: () => listeners.focus[0] != null,\n    }), [\n        canGoBack,\n        dispatch,\n        emitter,\n        getCurrentOptions,\n        getCurrentRoute,\n        getRootState,\n        listeners.focus,\n        resetRoot,\n    ]);\n    React.useImperativeHandle(ref, () => navigation, [navigation]);\n    const onDispatchAction = React.useCallback((action, noop) => {\n        emitter.emit({\n            type: '__unsafe_action__',\n            data: { action, noop, stack: stackRef.current },\n        });\n    }, [emitter]);\n    const lastEmittedOptionsRef = React.useRef();\n    const onOptionsChange = React.useCallback((options) => {\n        if (lastEmittedOptionsRef.current === options) {\n            return;\n        }\n        lastEmittedOptionsRef.current = options;\n        emitter.emit({\n            type: 'options',\n            data: { options },\n        });\n    }, [emitter]);\n    const stackRef = React.useRef();\n    const builderContext = React.useMemo(() => ({\n        addListener,\n        addKeyedListener,\n        onDispatchAction,\n        onOptionsChange,\n        stackRef,\n    }), [addListener, addKeyedListener, onDispatchAction, onOptionsChange]);\n    const scheduleContext = React.useMemo(() => ({ scheduleUpdate, flushUpdates }), [scheduleUpdate, flushUpdates]);\n    const isInitialRef = React.useRef(true);\n    const getIsInitial = React.useCallback(() => isInitialRef.current, []);\n    const context = React.useMemo(() => ({\n        state,\n        getState,\n        setState,\n        getKey,\n        setKey,\n        getIsInitial,\n        addOptionsGetter,\n    }), [\n        state,\n        getState,\n        setState,\n        getKey,\n        setKey,\n        getIsInitial,\n        addOptionsGetter,\n    ]);\n    const onStateChangeRef = React.useRef(onStateChange);\n    const stateRef = React.useRef(state);\n    React.useEffect(() => {\n        isInitialRef.current = false;\n        onStateChangeRef.current = onStateChange;\n        stateRef.current = state;\n    });\n    React.useEffect(() => {\n        const hydratedState = getRootState();\n        if (process.env.NODE_ENV !== 'production') {\n            if (hydratedState !== undefined) {\n                const serializableResult = checkSerializable(hydratedState);\n                if (!serializableResult.serializable) {\n                    const { location, reason } = serializableResult;\n                    let path = '';\n                    let pointer = hydratedState;\n                    let params = false;\n                    for (let i = 0; i < location.length; i++) {\n                        const curr = location[i];\n                        const prev = location[i - 1];\n                        pointer = pointer[curr];\n                        if (!params && curr === 'state') {\n                            continue;\n                        }\n                        else if (!params && curr === 'routes') {\n                            if (path) {\n                                path += ' > ';\n                            }\n                        }\n                        else if (!params &&\n                            typeof curr === 'number' &&\n                            prev === 'routes') {\n                            path += pointer?.name;\n                        }\n                        else if (!params) {\n                            path += ` > ${curr}`;\n                            params = true;\n                        }\n                        else {\n                            if (typeof curr === 'number' || /^[0-9]+$/.test(curr)) {\n                                path += `[${curr}]`;\n                            }\n                            else if (/^[a-z$_]+$/i.test(curr)) {\n                                path += `.${curr}`;\n                            }\n                            else {\n                                path += `[${JSON.stringify(curr)}]`;\n                            }\n                        }\n                    }\n                    const message = `Non-serializable values were found in the navigation state. Check:\\n\\n${path} (${reason})\\n\\nThis can break usage such as persisting and restoring state. This might happen if you passed non-serializable values such as function, class instances etc. in params. If you need to use components with callbacks in your options, you can use 'navigation.setOptions' instead. See https://reactnavigation.org/docs/troubleshooting#i-get-the-warning-non-serializable-values-were-found-in-the-navigation-state for more details.`;\n                    if (!serializableWarnings.includes(message)) {\n                        serializableWarnings.push(message);\n                        console.warn(message);\n                    }\n                }\n                const duplicateRouteNamesResult = checkDuplicateRouteNames(hydratedState);\n                if (duplicateRouteNamesResult.length) {\n                    const message = `Found screens with the same name nested inside one another. Check:\\n${duplicateRouteNamesResult.map((locations) => `\\n${locations.join(', ')}`)}\\n\\nThis can cause confusing behavior during navigation. Consider using unique names for each screen instead.`;\n                    if (!duplicateNameWarnings.includes(message)) {\n                        duplicateNameWarnings.push(message);\n                        console.warn(message);\n                    }\n                }\n            }\n        }\n        emitter.emit({ type: 'state', data: { state } });\n        if (!isFirstMountRef.current && onStateChangeRef.current) {\n            onStateChangeRef.current(hydratedState);\n        }\n        isFirstMountRef.current = false;\n    }, [getRootState, emitter, state]);\n    const defaultOnUnhandledAction = React.useCallback((action) => {\n        if (process.env.NODE_ENV === 'production') {\n            return;\n        }\n        const payload = action.payload;\n        let message = `The action '${action.type}'${payload ? ` with payload ${JSON.stringify(action.payload)}` : ''} was not handled by any navigator.`;\n        switch (action.type) {\n            case 'NAVIGATE':\n            case 'PUSH':\n            case 'REPLACE':\n            case 'JUMP_TO':\n                if (payload?.name) {\n                    message += `\\n\\nDo you have a screen named '${payload.name}'?\\n\\nIf you're trying to navigate to a screen in a nested navigator, see https://reactnavigation.org/docs/nesting-navigators#navigating-to-a-screen-in-a-nested-navigator.`;\n                }\n                else {\n                    message += `\\n\\nYou need to pass the name of the screen to navigate to.\\n\\nSee https://reactnavigation.org/docs/navigation-actions for usage.`;\n                }\n                break;\n            case 'GO_BACK':\n            case 'POP':\n            case 'POP_TO_TOP':\n                message += `\\n\\nIs there any screen to go back to?`;\n                break;\n            case 'OPEN_DRAWER':\n            case 'CLOSE_DRAWER':\n            case 'TOGGLE_DRAWER':\n                message += `\\n\\nIs your screen inside a Drawer navigator?`;\n                break;\n        }\n        message += `\\n\\nThis is a development-only warning and won't be shown in production.`;\n        console.error(message);\n    }, []);\n    let element = (<NavigationContainerRefContext.Provider value={navigation}>\n        <ScheduleUpdateContext.Provider value={scheduleContext}>\n          <NavigationBuilderContext.Provider value={builderContext}>\n            <NavigationStateContext.Provider value={context}>\n              <UnhandledActionContext.Provider value={onUnhandledAction ?? defaultOnUnhandledAction}>\n                <EnsureSingleNavigator>{children}</EnsureSingleNavigator>\n              </UnhandledActionContext.Provider>\n            </NavigationStateContext.Provider>\n          </NavigationBuilderContext.Provider>\n        </ScheduleUpdateContext.Provider>\n      </NavigationContainerRefContext.Provider>);\n    if (independent) {\n        // We need to clear any existing contexts for nested independent container to work correctly\n        element = (<NavigationRouteContext.Provider value={undefined}>\n          <NavigationContext.Provider value={undefined}>\n            {element}\n          </NavigationContext.Provider>\n        </NavigationRouteContext.Provider>);\n    }\n    return element;\n});\nexport default BaseNavigationContainer;\n", "export default function checkDuplicateRouteNames(state) {\n    const duplicates = [];\n    const getRouteNames = (location, state) => {\n        state.routes.forEach((route) => {\n            const currentLocation = location\n                ? `${location} > ${route.name}`\n                : route.name;\n            route.state?.routeNames?.forEach((routeName) => {\n                if (routeName === route.name) {\n                    duplicates.push([\n                        currentLocation,\n                        `${currentLocation} > ${route.name}`,\n                    ]);\n                }\n            });\n            if (route.state) {\n                getRouteNames(currentLocation, route.state);\n            }\n        });\n    };\n    getRouteNames('', state);\n    return duplicates;\n}\n", "const checkSerializableWithoutCircularReference = (o, seen, location) => {\n    if (o === undefined ||\n        o === null ||\n        typeof o === 'boolean' ||\n        typeof o === 'number' ||\n        typeof o === 'string') {\n        return { serializable: true };\n    }\n    if (Object.prototype.toString.call(o) !== '[object Object]' &&\n        !Array.isArray(o)) {\n        return {\n            serializable: false,\n            location,\n            reason: typeof o === 'function' ? 'Function' : String(o),\n        };\n    }\n    if (seen.has(o)) {\n        return {\n            serializable: false,\n            reason: 'Circular reference',\n            location,\n        };\n    }\n    seen.add(o);\n    if (Array.isArray(o)) {\n        for (let i = 0; i < o.length; i++) {\n            const childResult = checkSerializableWithoutCircularReference(o[i], new Set(seen), [...location, i]);\n            if (!childResult.serializable) {\n                return childResult;\n            }\n        }\n    }\n    else {\n        for (const key in o) {\n            const childResult = checkSerializableWithoutCircularReference(o[key], new Set(seen), [...location, key]);\n            if (!childResult.serializable) {\n                return childResult;\n            }\n        }\n    }\n    return { serializable: true };\n};\nexport default function checkSerializable(o) {\n    return checkSerializableWithoutCircularReference(o, new Set(), []);\n}\n", "import { CommonActions } from '@react-navigation/routers';\nexport const NOT_INITIALIZED_ERROR = \"The 'navigation' object hasn't been initialized yet. This might happen if you don't have a navigator mounted, or if the navigator hasn't finished mounting. See https://reactnavigation.org/docs/navigating-without-navigation-prop#handling-initialization for more details.\";\nexport default function createNavigationContainerRef() {\n    const methods = [\n        ...Object.keys(CommonActions),\n        'addListener',\n        'removeListener',\n        'resetRoot',\n        'dispatch',\n        'isFocused',\n        'canGoBack',\n        'getRootState',\n        'getState',\n        'getParent',\n        'getCurrentRoute',\n        'getCurrentOptions',\n    ];\n    const listeners = {};\n    const removeListener = (event, callback) => {\n        listeners[event] = listeners[event]?.filter((cb) => cb !== callback);\n    };\n    let current = null;\n    const ref = {\n        get current() {\n            return current;\n        },\n        set current(value) {\n            current = value;\n            if (value != null) {\n                Object.entries(listeners).forEach(([event, callbacks]) => {\n                    callbacks.forEach((callback) => {\n                        value.addListener(event, callback);\n                    });\n                });\n            }\n        },\n        isReady: () => {\n            if (current == null) {\n                return false;\n            }\n            return current.isReady();\n        },\n        ...methods.reduce((acc, name) => {\n            acc[name] = (...args) => {\n                if (current == null) {\n                    switch (name) {\n                        case 'addListener': {\n                            const [event, callback] = args;\n                            listeners[event] = listeners[event] || [];\n                            listeners[event].push(callback);\n                            return () => removeListener(event, callback);\n                        }\n                        case 'removeListener': {\n                            const [event, callback] = args;\n                            removeListener(event, callback);\n                            break;\n                        }\n                        default:\n                            console.error(NOT_INITIALIZED_ERROR);\n                    }\n                }\n                else {\n                    // @ts-expect-error: this is ok\n                    return current[name](...args);\n                }\n            };\n            return acc;\n        }, {}),\n    };\n    return ref;\n}\n", "import * as React from 'react';\nconst MULTIPLE_NAVIGATOR_ERROR = `Another navigator is already registered for this container. You likely have multiple navigators under a single \"NavigationContainer\" or \"Screen\". Make sure each navigator is under a separate \"Screen\" container. See https://reactnavigation.org/docs/nesting-navigators for a guide on nesting.`;\nexport const SingleNavigatorContext = React.createContext(undefined);\n/**\n * Component which ensures that there's only one navigator nested under it.\n */\nexport default function EnsureSingleNavigator({ children }) {\n    const navigatorKeyRef = React.useRef();\n    const value = React.useMemo(() => ({\n        register(key) {\n            const currentKey = navigatorKeyRef.current;\n            if (currentKey !== undefined && key !== currentKey) {\n                throw new Error(MULTIPLE_NAVIGATOR_ERROR);\n            }\n            navigatorKeyRef.current = key;\n        },\n        unregister(key) {\n            const currentKey = navigatorKeyRef.current;\n            if (key !== currentKey) {\n                return;\n            }\n            navigatorKeyRef.current = undefined;\n        },\n    }), []);\n    return (<SingleNavigatorContext.Provider value={value}>\n      {children}\n    </SingleNavigatorContext.Provider>);\n}\n", "export default function findFocusedRoute(state) {\n    let current = state;\n    while (current?.routes[current.index ?? 0].state != null) {\n        current = current.routes[current.index ?? 0].state;\n    }\n    const route = current?.routes[current?.index ?? 0];\n    return route;\n}\n", "import * as React from 'react';\n/**\n * Context which holds the required helpers needed to build nested navigators.\n */\nconst NavigationBuilderContext = React.createContext({\n    onDispatchAction: () => undefined,\n    onOptionsChange: () => undefined,\n});\nexport default NavigationBuilderContext;\n", "import * as React from 'react';\n/**\n * Context which holds the route prop for a screen.\n */\nconst NavigationContainerRefContext = React.createContext(undefined);\nexport default NavigationContainerRefContext;\n", "import * as React from 'react';\n/**\n * Context which holds the navigation prop for a screen.\n */\nconst NavigationContext = React.createContext(undefined);\nexport default NavigationContext;\n", "import * as React from 'react';\n/**\n * Context which holds the route prop for a screen.\n */\nconst NavigationRouteContext = React.createContext(undefined);\nexport default NavigationRouteContext;\n", "import * as React from 'react';\nconst MISSING_CONTEXT_ERROR = \"Couldn't find a navigation context. Have you wrapped your app with 'NavigationContainer'? See https://reactnavigation.org/docs/getting-started for setup instructions.\";\nexport default React.createContext({\n    isDefault: true,\n    get getKey() {\n        throw new Error(MISSING_CONTEXT_ERROR);\n    },\n    get setKey() {\n        throw new Error(MISSING_CONTEXT_ERROR);\n    },\n    get getState() {\n        throw new Error(MISSING_CONTEXT_ERROR);\n    },\n    get setState() {\n        throw new Error(MISSING_CONTEXT_ERROR);\n    },\n    get getIsInitial() {\n        throw new Error(MISSING_CONTEXT_ERROR);\n    },\n});\n", "import * as React from 'react';\nconst UnhandledActionContext = React.createContext(undefined);\nexport default UnhandledActionContext;\n", "import * as React from 'react';\n/**\n * Hook which lets child navigators add action listeners.\n */\nexport default function useChildListeners() {\n    const { current: listeners } = React.useRef({\n        action: [],\n        focus: [],\n    });\n    const addListener = React.useCallback((type, listener) => {\n        // @ts-expect-error: listener should be correct type according to `type`\n        listeners[type].push(listener);\n        return () => {\n            // @ts-expect-error: listener should be correct type according to `type`\n            const index = listeners[type].indexOf(listener);\n            listeners[type].splice(index, 1);\n        };\n    }, [listeners]);\n    return {\n        listeners,\n        addListener,\n    };\n}\n", "import * as React from 'react';\n/**\n * Hook to manage the event system used by the navigator to notify screens of various events.\n */\nexport default function useEventEmitter(listen) {\n    const listenRef = React.useRef(listen);\n    React.useEffect(() => {\n        listenRef.current = listen;\n    });\n    const listeners = React.useRef({});\n    const create = React.useCallback((target) => {\n        const removeListener = (type, callback) => {\n            const callbacks = listeners.current[type]\n                ? listeners.current[type][target]\n                : undefined;\n            if (!callbacks) {\n                return;\n            }\n            const index = callbacks.indexOf(callback);\n            callbacks.splice(index, 1);\n        };\n        const addListener = (type, callback) => {\n            listeners.current[type] = listeners.current[type] || {};\n            listeners.current[type][target] = listeners.current[type][target] || [];\n            listeners.current[type][target].push(callback);\n            return () => removeListener(type, callback);\n        };\n        return {\n            addListener,\n            removeListener,\n        };\n    }, []);\n    const emit = React.useCallback(({ type, data, target, canPreventDefault, }) => {\n        const items = listeners.current[type] || {};\n        // Copy the current list of callbacks in case they are mutated during execution\n        const callbacks = target !== undefined\n            ? items[target]?.slice()\n            : []\n                .concat(...Object.keys(items).map((t) => items[t]))\n                .filter((cb, i, self) => self.lastIndexOf(cb) === i);\n        const event = {\n            get type() {\n                return type;\n            },\n        };\n        if (target !== undefined) {\n            Object.defineProperty(event, 'target', {\n                enumerable: true,\n                get() {\n                    return target;\n                },\n            });\n        }\n        if (data !== undefined) {\n            Object.defineProperty(event, 'data', {\n                enumerable: true,\n                get() {\n                    return data;\n                },\n            });\n        }\n        if (canPreventDefault) {\n            let defaultPrevented = false;\n            Object.defineProperties(event, {\n                defaultPrevented: {\n                    enumerable: true,\n                    get() {\n                        return defaultPrevented;\n                    },\n                },\n                preventDefault: {\n                    enumerable: true,\n                    value() {\n                        defaultPrevented = true;\n                    },\n                },\n            });\n        }\n        listenRef.current?.(event);\n        callbacks?.forEach((cb) => cb(event));\n        return event;\n    }, []);\n    return React.useMemo(() => ({ create, emit }), [create, emit]);\n}\n", "import * as React from 'react';\n/**\n * Hook which lets child navigators add getters to be called for obtaining rehydrated state.\n */\nexport default function useKeyedChildListeners() {\n    const { current: keyedListeners } = React.useRef({\n        getState: {},\n        beforeRemove: {},\n    });\n    const addKeyedListener = React.useCallback((type, key, listener) => {\n        keyedListeners[type][key] = listener;\n        return () => {\n            keyedListeners[type][key] = undefined;\n        };\n    }, [keyedListeners]);\n    return {\n        keyedListeners,\n        addKeyedListener,\n    };\n}\n", "import * as React from 'react';\nimport NavigationBuilderContext from './NavigationBuilderContext';\nimport NavigationStateContext from './NavigationStateContext';\nexport default function useOptionsGetters({ key, options, navigation, }) {\n    const optionsRef = React.useRef(options);\n    const optionsGettersFromChildRef = React.useRef({});\n    const { onOptionsChange } = React.useContext(NavigationBuilderContext);\n    const { addOptionsGetter: parentAddOptionsGetter } = React.useContext(NavigationStateContext);\n    const optionsChangeListener = React.useCallback(() => {\n        const isFocused = navigation?.isFocused() ?? true;\n        const hasChildren = Object.keys(optionsGettersFromChildRef.current).length;\n        if (isFocused && !hasChildren) {\n            onOptionsChange(optionsRef.current ?? {});\n        }\n    }, [navigation, onOptionsChange]);\n    React.useEffect(() => {\n        optionsRef.current = options;\n        optionsChangeListener();\n        return navigation?.addListener('focus', optionsChangeListener);\n    }, [navigation, options, optionsChangeListener]);\n    const getOptionsFromListener = React.useCallback(() => {\n        for (let key in optionsGettersFromChildRef.current) {\n            if (optionsGettersFromChildRef.current.hasOwnProperty(key)) {\n                const result = optionsGettersFromChildRef.current[key]?.();\n                // null means unfocused route\n                if (result !== null) {\n                    return result;\n                }\n            }\n        }\n        return null;\n    }, []);\n    const getCurrentOptions = React.useCallback(() => {\n        const isFocused = navigation?.isFocused() ?? true;\n        if (!isFocused) {\n            return null;\n        }\n        const optionsFromListener = getOptionsFromListener();\n        if (optionsFromListener !== null) {\n            return optionsFromListener;\n        }\n        return optionsRef.current;\n    }, [navigation, getOptionsFromListener]);\n    React.useEffect(() => {\n        return parentAddOptionsGetter?.(key, getCurrentOptions);\n    }, [getCurrentOptions, parentAddOptionsGetter, key]);\n    const addOptionsGetter = React.useCallback((key, getter) => {\n        optionsGettersFromChildRef.current[key] = getter;\n        optionsChangeListener();\n        return () => {\n            // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n            delete optionsGettersFromChildRef.current[key];\n            optionsChangeListener();\n        };\n    }, [optionsChangeListener]);\n    return {\n        addOptionsGetter,\n        getCurrentOptions,\n    };\n}\n", "import * as React from 'react';\nconst MISSING_CONTEXT_ERROR = \"Couldn't find a schedule context.\";\nexport const ScheduleUpdateContext = React.createContext({\n    scheduleUpdate() {\n        throw new Error(MISSING_CONTEXT_ERROR);\n    },\n    flushUpdates() {\n        throw new Error(MISSING_CONTEXT_ERROR);\n    },\n});\n/**\n * When screen config changes, we want to update the navigator in the same update phase.\n * However, navigation state is in the root component and React won't let us update it from a child.\n * This is a workaround for that, the scheduled update is stored in the ref without actually calling setState.\n * It lets all subsequent updates access the latest state so it stays correct.\n * Then we call setState during after the component updates.\n */\nexport default function useScheduleUpdate(callback) {\n    const { scheduleUpdate, flushUpdates } = React.useContext(ScheduleUpdateContext);\n    scheduleUpdate(callback);\n    React.useEffect(flushUpdates);\n}\n", "import * as React from 'react';\nconst UNINTIALIZED_STATE = {};\n/**\n * This is definitely not compatible with concurrent mode, but we don't have a solution for sync state yet.\n */\nexport default function useSyncState(initialState) {\n    const stateRef = React.useRef(UNINTIALIZED_STATE);\n    const isSchedulingRef = React.useRef(false);\n    const isMountedRef = React.useRef(true);\n    React.useEffect(() => {\n        isMountedRef.current = true;\n        return () => {\n            isMountedRef.current = false;\n        };\n    }, []);\n    if (stateRef.current === UNINTIALIZED_STATE) {\n        stateRef.current =\n            // @ts-expect-error: initialState is a function, but TypeScript doesn't think so\n            typeof initialState === 'function' ? initialState() : initialState;\n    }\n    const [trackingState, setTrackingState] = React.useState(stateRef.current);\n    const getState = React.useCallback(() => stateRef.current, []);\n    const setState = React.useCallback((state) => {\n        if (state === stateRef.current || !isMountedRef.current) {\n            return;\n        }\n        stateRef.current = state;\n        if (!isSchedulingRef.current) {\n            setTrackingState(state);\n        }\n    }, []);\n    const scheduleUpdate = React.useCallback((callback) => {\n        isSchedulingRef.current = true;\n        try {\n            callback();\n        }\n        finally {\n            isSchedulingRef.current = false;\n        }\n    }, []);\n    const flushUpdates = React.useCallback(() => {\n        if (!isMountedRef.current) {\n            return;\n        }\n        // Make sure that the tracking state is up-to-date.\n        // We call it unconditionally, but React should skip the update if state is unchanged.\n        setTrackingState(stateRef.current);\n    }, []);\n    // If we're rendering and the tracking state is out of date, update it immediately\n    // This will make sure that our updates are applied as early as possible.\n    if (trackingState !== stateRef.current) {\n        setTrackingState(stateRef.current);\n    }\n    const state = stateRef.current;\n    React.useDebugValue(state);\n    return [state, getState, setState, scheduleUpdate, flushUpdates];\n}\n", "/**\n * Empty component used for grouping screen configs.\n */\nexport default function Group(_) {\n    /* istanbul ignore next */\n    return null;\n}\n", "/**\n * Empty component used for specifying route configuration.\n */\nexport default function Screen(_) {\n    /* istanbul ignore next */\n    return null;\n}\n", "import Group from './Group';\nimport Screen from './Screen';\n/**\n * Higher order component to create a `Navigator` and `Screen` pair.\n * Custom navigators should wrap the navigator component in `createNavigator` before exporting.\n *\n * @param Navigator The navigtor component to wrap.\n * @returns Factory method to create a `Navigator` and `Screen` pair.\n */\nexport default function createNavigatorFactory(Navigator) {\n    return function () {\n        if (arguments[0] !== undefined) {\n            throw new Error(\"Creating a navigator doesn't take an argument. Maybe you are trying to use React Navigation 4 API? See https://reactnavigation.org/docs/hello-react-navigation for the latest API and guides.\");\n        }\n        return {\n            Navigator,\n            Group,\n            Screen,\n        };\n    };\n}\n", "import * as React from 'react';\n/**\n * Context which holds the values for the current navigation tree.\n * Intended for use in SSR. This is not safe to use on the client.\n */\nconst CurrentRenderContext = React.createContext(undefined);\nexport default CurrentRenderContext;\n", "export default function getActionFromState(state, options) {\n    // Create a normalized configs object which will be easier to use\n    const normalizedConfig = options\n        ? createNormalizedConfigItem(options)\n        : {};\n    const routes = state.index != null ? state.routes.slice(0, state.index + 1) : state.routes;\n    if (routes.length === 0) {\n        return undefined;\n    }\n    if (!((routes.length === 1 && routes[0].key === undefined) ||\n        (routes.length === 2 &&\n            routes[0].key === undefined &&\n            routes[0].name === normalizedConfig?.initialRouteName &&\n            routes[1].key === undefined))) {\n        return {\n            type: 'RESET',\n            payload: state,\n        };\n    }\n    const route = state.routes[state.index ?? state.routes.length - 1];\n    let current = route?.state;\n    let config = normalizedConfig?.screens?.[route?.name];\n    let params = { ...route.params };\n    let payload = route\n        ? { name: route.name, path: route.path, params }\n        : undefined;\n    while (current) {\n        if (current.routes.length === 0) {\n            return undefined;\n        }\n        const routes = current.index != null\n            ? current.routes.slice(0, current.index + 1)\n            : current.routes;\n        const route = routes[routes.length - 1];\n        // Explicitly set to override existing value when merging params\n        Object.assign(params, {\n            initial: undefined,\n            screen: undefined,\n            params: undefined,\n            state: undefined,\n        });\n        if (routes.length === 1 && routes[0].key === undefined) {\n            params.initial = true;\n            params.screen = route.name;\n        }\n        else if (routes.length === 2 &&\n            routes[0].key === undefined &&\n            routes[0].name === config?.initialRouteName &&\n            routes[1].key === undefined) {\n            params.initial = false;\n            params.screen = route.name;\n        }\n        else {\n            params.state = current;\n            break;\n        }\n        if (route.state) {\n            params.params = { ...route.params };\n            params = params.params;\n        }\n        else {\n            params.path = route.path;\n            params.params = route.params;\n        }\n        current = route.state;\n        config = config?.screens?.[route.name];\n    }\n    if (!payload) {\n        return;\n    }\n    // Try to construct payload for a `NAVIGATE` action from the state\n    // This lets us preserve the navigation state and not lose it\n    return {\n        type: 'NAVIGATE',\n        payload,\n    };\n}\nconst createNormalizedConfigItem = (config) => typeof config === 'object' && config != null\n    ? {\n        initialRouteName: config.initialRouteName,\n        screens: config.screens != null\n            ? createNormalizedConfigs(config.screens)\n            : undefined,\n    }\n    : {};\nconst createNormalizedConfigs = (options) => Object.entries(options).reduce((acc, [k, v]) => {\n    acc[k] = createNormalizedConfigItem(v);\n    return acc;\n}, {});\n", "import * as React from 'react';\n/**\n * Utilites such as `getFocusedRouteNameFromRoute` need to access state.\n * So we need a way to suppress the warning for those use cases.\n * This is fine since they are internal utilities and this is not public API.\n */\nexport const CHILD_STATE = Symbol('CHILD_STATE');\n/**\n * Hook to cache route props for each screen in the navigator.\n * This lets add warnings and modifications to the route object but keep references between renders.\n */\nexport default function useRouteCache(routes) {\n    // Cache object which holds route objects for each screen\n    const cache = React.useMemo(() => ({ current: new Map() }), []);\n    if (process.env.NODE_ENV === 'production') {\n        // We don't want the overhead of creating extra maps every render in prod\n        return routes;\n    }\n    cache.current = routes.reduce((acc, route) => {\n        const previous = cache.current.get(route);\n        if (previous) {\n            // If a cached route object already exists, reuse it\n            acc.set(route, previous);\n        }\n        else {\n            const { state, ...proxy } = route;\n            Object.defineProperty(proxy, CHILD_STATE, {\n                enumerable: false,\n                value: state,\n            });\n            acc.set(route, proxy);\n        }\n        return acc;\n    }, new Map());\n    return Array.from(cache.current.values());\n}\n", "import { CHILD_STATE } from './useRouteCache';\nexport default function getFocusedRouteNameFromRoute(route) {\n    // @ts-expect-error: this isn't in type definitions coz we want this private\n    const state = route[CHILD_STATE] ?? route.state;\n    const params = route.params;\n    const routeName = state\n        ? // Get the currently active route name in the nested navigator\n            state.routes[\n            // If we have a partial state without index, for tab/drawer, first screen will be focused one, and last for stack\n            // The type property will only exist for rehydrated state and not for state from deep link\n            state.index ??\n                (typeof state.type === 'string' && state.type !== 'stack'\n                    ? 0\n                    : state.routes.length - 1)].name\n        : // If state doesn't exist, we need to default to `screen` param if available\n            typeof params?.screen === 'string'\n                ? params.screen\n                : undefined;\n    return routeName;\n}\n", "import * as queryString from 'query-string';\nimport fromEntries from './fromEntries';\nimport validatePathConfig from './validatePathConfig';\nconst getActiveRoute = (state) => {\n    const route = typeof state.index === 'number'\n        ? state.routes[state.index]\n        : state.routes[state.routes.length - 1];\n    if (route.state) {\n        return getActiveRoute(route.state);\n    }\n    return route;\n};\n/**\n * Utility to serialize a navigation state object to a path string.\n *\n * @example\n * ```js\n * getPathFromState(\n *   {\n *     routes: [\n *       {\n *         name: 'Chat',\n *         params: { author: 'Jane', id: 42 },\n *       },\n *     ],\n *   },\n *   {\n *     screens: {\n *       Chat: {\n *         path: 'chat/:author/:id',\n *         stringify: { author: author => author.toLowerCase() }\n *       }\n *     }\n *   }\n * )\n * ```\n *\n * @param state Navigation state to serialize.\n * @param options Extra options to fine-tune how to serialize the path.\n * @returns Path representing the state, e.g. /foo/bar?count=42.\n */\nexport default function getPathFromState(state, options) {\n    if (state == null) {\n        throw Error(\"Got 'undefined' for the navigation state. You must pass a valid state object.\");\n    }\n    if (options) {\n        validatePathConfig(options);\n    }\n    // Create a normalized configs object which will be easier to use\n    const configs = options?.screens\n        ? createNormalizedConfigs(options?.screens)\n        : {};\n    let path = '/';\n    let current = state;\n    const allParams = {};\n    while (current) {\n        let index = typeof current.index === 'number' ? current.index : 0;\n        let route = current.routes[index];\n        let pattern;\n        let focusedParams;\n        let focusedRoute = getActiveRoute(state);\n        let currentOptions = configs;\n        // Keep all the route names that appeared during going deeper in config in case the pattern is resolved to undefined\n        let nestedRouteNames = [];\n        let hasNext = true;\n        while (route.name in currentOptions && hasNext) {\n            pattern = currentOptions[route.name].pattern;\n            nestedRouteNames.push(route.name);\n            if (route.params) {\n                const stringify = currentOptions[route.name]?.stringify;\n                const currentParams = fromEntries(Object.entries(route.params).map(([key, value]) => [\n                    key,\n                    stringify?.[key] ? stringify[key](value) : String(value),\n                ]));\n                if (pattern) {\n                    Object.assign(allParams, currentParams);\n                }\n                if (focusedRoute === route) {\n                    // If this is the focused route, keep the params for later use\n                    // We save it here since it's been stringified already\n                    focusedParams = { ...currentParams };\n                    pattern\n                        ?.split('/')\n                        .filter((p) => p.startsWith(':'))\n                        // eslint-disable-next-line no-loop-func\n                        .forEach((p) => {\n                        const name = getParamName(p);\n                        // Remove the params present in the pattern since we'll only use the rest for query string\n                        if (focusedParams) {\n                            // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n                            delete focusedParams[name];\n                        }\n                    });\n                }\n            }\n            // If there is no `screens` property or no nested state, we return pattern\n            if (!currentOptions[route.name].screens || route.state === undefined) {\n                hasNext = false;\n            }\n            else {\n                index =\n                    typeof route.state.index === 'number'\n                        ? route.state.index\n                        : route.state.routes.length - 1;\n                const nextRoute = route.state.routes[index];\n                const nestedConfig = currentOptions[route.name].screens;\n                // if there is config for next route name, we go deeper\n                if (nestedConfig && nextRoute.name in nestedConfig) {\n                    route = nextRoute;\n                    currentOptions = nestedConfig;\n                }\n                else {\n                    // If not, there is no sense in going deeper in config\n                    hasNext = false;\n                }\n            }\n        }\n        if (pattern === undefined) {\n            pattern = nestedRouteNames.join('/');\n        }\n        if (currentOptions[route.name] !== undefined) {\n            path += pattern\n                .split('/')\n                .map((p) => {\n                const name = getParamName(p);\n                // We don't know what to show for wildcard patterns\n                // Showing the route name seems ok, though whatever we show here will be incorrect\n                // Since the page doesn't actually exist\n                if (p === '*') {\n                    return route.name;\n                }\n                // If the path has a pattern for a param, put the param in the path\n                if (p.startsWith(':')) {\n                    const value = allParams[name];\n                    if (value === undefined && p.endsWith('?')) {\n                        // Optional params without value assigned in route.params should be ignored\n                        return '';\n                    }\n                    return encodeURIComponent(value);\n                }\n                return encodeURIComponent(p);\n            })\n                .join('/');\n        }\n        else {\n            path += encodeURIComponent(route.name);\n        }\n        if (!focusedParams) {\n            focusedParams = focusedRoute.params;\n        }\n        if (route.state) {\n            path += '/';\n        }\n        else if (focusedParams) {\n            for (let param in focusedParams) {\n                if (focusedParams[param] === 'undefined') {\n                    // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n                    delete focusedParams[param];\n                }\n            }\n            const query = queryString.stringify(focusedParams, { sort: false });\n            if (query) {\n                path += `?${query}`;\n            }\n        }\n        current = route.state;\n    }\n    // Remove multiple as well as trailing slashes\n    path = path.replace(/\\/+/g, '/');\n    path = path.length > 1 ? path.replace(/\\/$/, '') : path;\n    return path;\n}\nconst getParamName = (pattern) => pattern.replace(/^:/, '').replace(/\\?$/, '');\nconst joinPaths = (...paths) => []\n    .concat(...paths.map((p) => p.split('/')))\n    .filter(Boolean)\n    .join('/');\nconst createConfigItem = (config, parentPattern) => {\n    if (typeof config === 'string') {\n        // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\n        const pattern = parentPattern ? joinPaths(parentPattern, config) : config;\n        return { pattern };\n    }\n    // If an object is specified as the value (e.g. Foo: { ... }),\n    // It can have `path` property and `screens` prop which has nested configs\n    let pattern;\n    if (config.exact && config.path === undefined) {\n        throw new Error(\"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\");\n    }\n    pattern =\n        config.exact !== true\n            ? joinPaths(parentPattern || '', config.path || '')\n            : config.path || '';\n    const screens = config.screens\n        ? createNormalizedConfigs(config.screens, pattern)\n        : undefined;\n    return {\n        // Normalize pattern to remove any leading, trailing slashes, duplicate slashes etc.\n        pattern: pattern?.split('/').filter(Boolean).join('/'),\n        stringify: config.stringify,\n        screens,\n    };\n};\nconst createNormalizedConfigs = (options, pattern) => fromEntries(Object.entries(options).map(([name, c]) => {\n    const result = createConfigItem(c, pattern);\n    return [name, result];\n}));\n", "// Object.fromEntries is not available in older iOS versions\nexport default function fromEntries(entries) {\n    return entries.reduce((acc, [k, v]) => {\n        if (acc.hasOwnProperty(k)) {\n            throw new Error(`A value for key '${k}' already exists in the object.`);\n        }\n        acc[k] = v;\n        return acc;\n    }, {});\n}\n", "const formatToList = (items) => items.map((key) => `- ${key}`).join('\\n');\nexport default function validatePathConfig(config, root = true) {\n    const validKeys = ['initialRouteName', 'screens'];\n    if (!root) {\n        validKeys.push('path', 'exact', 'stringify', 'parse');\n    }\n    const invalidKeys = Object.keys(config).filter((key) => !validKeys.includes(key));\n    if (invalidKeys.length) {\n        throw new Error(`Found invalid properties in the configuration:\\n${formatToList(invalidKeys)}\\n\\nDid you forget to specify them under a 'screens' property?\\n\\nYou can only specify the following properties:\\n${formatToList(validKeys)}\\n\\nSee https://reactnavigation.org/docs/configuring-links for more details on how to specify a linking configuration.`);\n    }\n    if (config.screens) {\n        Object.entries(config.screens).forEach(([_, value]) => {\n            if (typeof value !== 'string') {\n                validatePathConfig(value, false);\n            }\n        });\n    }\n}\n", "import escape from 'escape-string-regexp';\nimport * as queryString from 'query-string';\nimport findFocusedRoute from './findFocusedRoute';\nimport validatePathConfig from './validatePathConfig';\n/**\n * Utility to parse a path string to initial state object accepted by the container.\n * This is useful for deep linking when we need to handle the incoming URL.\n *\n * @example\n * ```js\n * getStateFromPath(\n *   '/chat/jane/42',\n *   {\n *     screens: {\n *       Chat: {\n *         path: 'chat/:author/:id',\n *         parse: { id: Number }\n *       }\n *     }\n *   }\n * )\n * ```\n * @param path Path string to parse and convert, e.g. /foo/bar?count=42.\n * @param options Extra options to fine-tune how to parse the path.\n */\nexport default function getStateFromPath(path, options) {\n    if (options) {\n        validatePathConfig(options);\n    }\n    let initialRoutes = [];\n    if (options?.initialRouteName) {\n        initialRoutes.push({\n            initialRouteName: options.initialRouteName,\n            parentScreens: [],\n        });\n    }\n    const screens = options?.screens;\n    let remaining = path\n        .replace(/\\/+/g, '/') // Replace multiple slash (//) with single ones\n        .replace(/^\\//, '') // Remove extra leading slash\n        .replace(/\\?.*$/, ''); // Remove query params which we will handle later\n    // Make sure there is a trailing slash\n    remaining = remaining.endsWith('/') ? remaining : `${remaining}/`;\n    if (screens === undefined) {\n        // When no config is specified, use the path segments as route names\n        const routes = remaining\n            .split('/')\n            .filter(Boolean)\n            .map((segment) => {\n            const name = decodeURIComponent(segment);\n            return { name };\n        });\n        if (routes.length) {\n            return createNestedStateObject(path, routes, initialRoutes);\n        }\n        return undefined;\n    }\n    // Create a normalized configs array which will be easier to use\n    const configs = []\n        .concat(...Object.keys(screens).map((key) => createNormalizedConfigs(key, screens, [], initialRoutes, [])))\n        .sort((a, b) => {\n        // Sort config so that:\n        // - the most exhaustive ones are always at the beginning\n        // - patterns with wildcard are always at the end\n        // If 2 patterns are same, move the one with less route names up\n        // This is an error state, so it's only useful for consistent error messages\n        if (a.pattern === b.pattern) {\n            return b.routeNames.join('>').localeCompare(a.routeNames.join('>'));\n        }\n        // If one of the patterns starts with the other, it's more exhaustive\n        // So move it up\n        if (a.pattern.startsWith(b.pattern)) {\n            return -1;\n        }\n        if (b.pattern.startsWith(a.pattern)) {\n            return 1;\n        }\n        const aParts = a.pattern.split('/');\n        const bParts = b.pattern.split('/');\n        for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {\n            // if b is longer, b get higher priority\n            if (aParts[i] == null) {\n                return 1;\n            }\n            // if a is longer, a get higher priority\n            if (bParts[i] == null) {\n                return -1;\n            }\n            const aWildCard = aParts[i] === '*' || aParts[i].startsWith(':');\n            const bWildCard = bParts[i] === '*' || bParts[i].startsWith(':');\n            // if both are wildcard we compare next component\n            if (aWildCard && bWildCard) {\n                continue;\n            }\n            // if only a is wild card, b get higher priority\n            if (aWildCard) {\n                return 1;\n            }\n            // if only b is wild card, a get higher priority\n            if (bWildCard) {\n                return -1;\n            }\n        }\n        return bParts.length - aParts.length;\n    });\n    // Check for duplicate patterns in the config\n    configs.reduce((acc, config) => {\n        if (acc[config.pattern]) {\n            const a = acc[config.pattern].routeNames;\n            const b = config.routeNames;\n            // It's not a problem if the path string omitted from a inner most screen\n            // For example, it's ok if a path resolves to `A > B > C` or `A > B`\n            const intersects = a.length > b.length\n                ? b.every((it, i) => a[i] === it)\n                : a.every((it, i) => b[i] === it);\n            if (!intersects) {\n                throw new Error(`Found conflicting screens with the same pattern. The pattern '${config.pattern}' resolves to both '${a.join(' > ')}' and '${b.join(' > ')}'. Patterns must be unique and cannot resolve to more than one screen.`);\n            }\n        }\n        return Object.assign(acc, {\n            [config.pattern]: config,\n        });\n    }, {});\n    if (remaining === '/') {\n        // We need to add special handling of empty path so navigation to empty path also works\n        // When handling empty path, we should only look at the root level config\n        const match = configs.find((config) => config.path === '' &&\n            config.routeNames.every(\n            // Make sure that none of the parent configs have a non-empty path defined\n            (name) => !configs.find((c) => c.screen === name)?.path));\n        if (match) {\n            return createNestedStateObject(path, match.routeNames.map((name) => ({ name })), initialRoutes, configs);\n        }\n        return undefined;\n    }\n    let result;\n    let current;\n    // We match the whole path against the regex instead of segments\n    // This makes sure matches such as wildcard will catch any unmatched routes, even if nested\n    const { routes, remainingPath } = matchAgainstConfigs(remaining, configs.map((c) => ({\n        ...c,\n        // Add `$` to the regex to make sure it matches till end of the path and not just beginning\n        regex: c.regex ? new RegExp(c.regex.source + '$') : undefined,\n    })));\n    if (routes !== undefined) {\n        // This will always be empty if full path matched\n        current = createNestedStateObject(path, routes, initialRoutes, configs);\n        remaining = remainingPath;\n        result = current;\n    }\n    if (current == null || result == null) {\n        return undefined;\n    }\n    return result;\n}\nconst joinPaths = (...paths) => []\n    .concat(...paths.map((p) => p.split('/')))\n    .filter(Boolean)\n    .join('/');\nconst matchAgainstConfigs = (remaining, configs) => {\n    let routes;\n    let remainingPath = remaining;\n    // Go through all configs, and see if the next path segment matches our regex\n    for (const config of configs) {\n        if (!config.regex) {\n            continue;\n        }\n        const match = remainingPath.match(config.regex);\n        // If our regex matches, we need to extract params from the path\n        if (match) {\n            const matchedParams = config.pattern\n                ?.split('/')\n                .filter((p) => p.startsWith(':'))\n                .reduce((acc, p, i) => Object.assign(acc, {\n                // The param segments appear every second item starting from 2 in the regex match result\n                [p]: match[(i + 1) * 2].replace(/\\//, ''),\n            }), {});\n            routes = config.routeNames.map((name) => {\n                const config = configs.find((c) => c.screen === name);\n                const params = config?.path\n                    ?.split('/')\n                    .filter((p) => p.startsWith(':'))\n                    .reduce((acc, p) => {\n                    const value = matchedParams[p];\n                    if (value) {\n                        const key = p.replace(/^:/, '').replace(/\\?$/, '');\n                        acc[key] = config.parse?.[key] ? config.parse[key](value) : value;\n                    }\n                    return acc;\n                }, {});\n                if (params && Object.keys(params).length) {\n                    return { name, params };\n                }\n                return { name };\n            });\n            remainingPath = remainingPath.replace(match[1], '');\n            break;\n        }\n    }\n    return { routes, remainingPath };\n};\nconst createNormalizedConfigs = (screen, routeConfig, routeNames = [], initials, parentScreens, parentPattern) => {\n    const configs = [];\n    routeNames.push(screen);\n    parentScreens.push(screen);\n    // @ts-expect-error: we can't strongly typecheck this for now\n    const config = routeConfig[screen];\n    if (typeof config === 'string') {\n        // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\n        const pattern = parentPattern ? joinPaths(parentPattern, config) : config;\n        configs.push(createConfigItem(screen, routeNames, pattern, config));\n    }\n    else if (typeof config === 'object') {\n        let pattern;\n        // if an object is specified as the value (e.g. Foo: { ... }),\n        // it can have `path` property and\n        // it could have `screens` prop which has nested configs\n        if (typeof config.path === 'string') {\n            if (config.exact && config.path === undefined) {\n                throw new Error(\"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\");\n            }\n            pattern =\n                config.exact !== true\n                    ? joinPaths(parentPattern || '', config.path || '')\n                    : config.path || '';\n            configs.push(createConfigItem(screen, routeNames, pattern, config.path, config.parse));\n        }\n        if (config.screens) {\n            // property `initialRouteName` without `screens` has no purpose\n            if (config.initialRouteName) {\n                initials.push({\n                    initialRouteName: config.initialRouteName,\n                    parentScreens,\n                });\n            }\n            Object.keys(config.screens).forEach((nestedConfig) => {\n                const result = createNormalizedConfigs(nestedConfig, config.screens, routeNames, initials, [...parentScreens], pattern ?? parentPattern);\n                configs.push(...result);\n            });\n        }\n    }\n    routeNames.pop();\n    return configs;\n};\nconst createConfigItem = (screen, routeNames, pattern, path, parse) => {\n    // Normalize pattern to remove any leading, trailing slashes, duplicate slashes etc.\n    pattern = pattern.split('/').filter(Boolean).join('/');\n    const regex = pattern\n        ? new RegExp(`^(${pattern\n            .split('/')\n            .map((it) => {\n            if (it.startsWith(':')) {\n                return `(([^/]+\\\\/)${it.endsWith('?') ? '?' : ''})`;\n            }\n            return `${it === '*' ? '.*' : escape(it)}\\\\/`;\n        })\n            .join('')})`)\n        : undefined;\n    return {\n        screen,\n        regex,\n        pattern,\n        path,\n        // The routeNames array is mutated, so copy it to keep the current state\n        routeNames: [...routeNames],\n        parse,\n    };\n};\nconst findParseConfigForRoute = (routeName, flatConfig) => {\n    for (const config of flatConfig) {\n        if (routeName === config.routeNames[config.routeNames.length - 1]) {\n            return config.parse;\n        }\n    }\n    return undefined;\n};\n// Try to find an initial route connected with the one passed\nconst findInitialRoute = (routeName, parentScreens, initialRoutes) => {\n    for (const config of initialRoutes) {\n        if (parentScreens.length === config.parentScreens.length) {\n            let sameParents = true;\n            for (let i = 0; i < parentScreens.length; i++) {\n                if (parentScreens[i].localeCompare(config.parentScreens[i]) !== 0) {\n                    sameParents = false;\n                    break;\n                }\n            }\n            if (sameParents) {\n                return routeName !== config.initialRouteName\n                    ? config.initialRouteName\n                    : undefined;\n            }\n        }\n    }\n    return undefined;\n};\n// returns state object with values depending on whether\n// it is the end of state and if there is initialRoute for this level\nconst createStateObject = (initialRoute, route, isEmpty) => {\n    if (isEmpty) {\n        if (initialRoute) {\n            return {\n                index: 1,\n                routes: [{ name: initialRoute }, route],\n            };\n        }\n        else {\n            return {\n                routes: [route],\n            };\n        }\n    }\n    else {\n        if (initialRoute) {\n            return {\n                index: 1,\n                routes: [{ name: initialRoute }, { ...route, state: { routes: [] } }],\n            };\n        }\n        else {\n            return {\n                routes: [{ ...route, state: { routes: [] } }],\n            };\n        }\n    }\n};\nconst createNestedStateObject = (path, routes, initialRoutes, flatConfig) => {\n    let state;\n    let route = routes.shift();\n    const parentScreens = [];\n    let initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);\n    parentScreens.push(route.name);\n    state = createStateObject(initialRoute, route, routes.length === 0);\n    if (routes.length > 0) {\n        let nestedState = state;\n        while ((route = routes.shift())) {\n            initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);\n            const nestedStateIndex = nestedState.index || nestedState.routes.length - 1;\n            nestedState.routes[nestedStateIndex].state = createStateObject(initialRoute, route, routes.length === 0);\n            if (routes.length > 0) {\n                nestedState = nestedState.routes[nestedStateIndex]\n                    .state;\n            }\n            parentScreens.push(route.name);\n        }\n    }\n    route = findFocusedRoute(state);\n    route.path = path;\n    const params = parseQueryParams(path, flatConfig ? findParseConfigForRoute(route.name, flatConfig) : undefined);\n    if (params) {\n        route.params = { ...route.params, ...params };\n    }\n    return state;\n};\nconst parseQueryParams = (path, parseConfig) => {\n    const query = path.split('?')[1];\n    const params = queryString.parse(query);\n    if (parseConfig) {\n        Object.keys(params).forEach((name) => {\n            if (parseConfig[name] && typeof params[name] === 'string') {\n                params[name] = parseConfig[name](params[name]);\n            }\n        });\n    }\n    return Object.keys(params).length ? params : undefined;\n};\n", "import * as React from 'react';\n/**\n * Context which holds the navigation helpers of the parent navigator.\n * Navigators should use this context in their view component.\n */\nconst NavigationHelpersContext = React.createContext(undefined);\nexport default NavigationHelpersContext;\n", "export class PrivateValueStore {\n    /**\n     * UGLY HACK! DO NOT USE THE TYPE!!!\n     *\n     * TypeScript requires a type to be used to be able to infer it.\n     * The type should exist as its own without any operations such as union.\n     * So we need to figure out a way to store this type in a property.\n     * The problem with a normal property is that it shows up in intelliSense.\n     * Adding private keyword works, but the annotation is stripped away in declaration.\n     * Turns out if we use an empty string, it doesn't show up in intelliSense.\n     */\n    '';\n}\n", "import * as React from 'react';\nimport useNavigation from './useNavigation';\n/**\n * Hook to run an effect in a focused screen, similar to `React.useEffect`.\n * This can be used to perform side-effects such as fetching data or subscribing to events.\n * The passed callback should be wrapped in `React.useCallback` to avoid running the effect too often.\n *\n * @param callback Memoized callback containing the effect, should optionally return a cleanup function.\n */\nexport default function useFocusEffect(effect) {\n    const navigation = useNavigation();\n    if (arguments[1] !== undefined) {\n        const message = \"You passed a second argument to 'useFocusEffect', but it only accepts one argument. \" +\n            \"If you want to pass a dependency array, you can use 'React.useCallback':\\n\\n\" +\n            'useFocusEffect(\\n' +\n            '  React.useCallback(() => {\\n' +\n            '    // Your code here\\n' +\n            '  }, [depA, depB])\\n' +\n            ');\\n\\n' +\n            'See usage guide: https://reactnavigation.org/docs/use-focus-effect';\n        console.error(message);\n    }\n    React.useEffect(() => {\n        let isFocused = false;\n        let cleanup;\n        const callback = () => {\n            const destroy = effect();\n            if (destroy === undefined || typeof destroy === 'function') {\n                return destroy;\n            }\n            if (process.env.NODE_ENV !== 'production') {\n                let message = 'An effect function must not return anything besides a function, which is used for clean-up.';\n                if (destroy === null) {\n                    message +=\n                        \" You returned 'null'. If your effect does not require clean-up, return 'undefined' (or nothing).\";\n                }\n                else if (typeof destroy.then === 'function') {\n                    message +=\n                        \"\\n\\nIt looks like you wrote 'useFocusEffect(async () => ...)' or returned a Promise. \" +\n                            'Instead, write the async function inside your effect ' +\n                            'and call it immediately:\\n\\n' +\n                            'useFocusEffect(\\n' +\n                            '  React.useCallback() => {\\n' +\n                            '    async function fetchData() {\\n' +\n                            '      // You can await here\\n' +\n                            '      const response = await MyAPI.getData(someId);\\n' +\n                            '      // ...\\n' +\n                            '    }\\n\\n' +\n                            '    fetchData();\\n' +\n                            '  }, [someId])\\n' +\n                            ');\\n\\n' +\n                            'See usage guide: https://reactnavigation.org/docs/use-focus-effect';\n                }\n                else {\n                    message += ` You returned '${JSON.stringify(destroy)}'.`;\n                }\n                console.error(message);\n            }\n        };\n        // We need to run the effect on intial render/dep changes if the screen is focused\n        if (navigation.isFocused()) {\n            cleanup = callback();\n            isFocused = true;\n        }\n        const unsubscribeFocus = navigation.addListener('focus', () => {\n            // If callback was already called for focus, avoid calling it again\n            // The focus event may also fire on intial render, so we guard against runing the effect twice\n            if (isFocused) {\n                return;\n            }\n            if (cleanup !== undefined) {\n                cleanup();\n            }\n            cleanup = callback();\n            isFocused = true;\n        });\n        const unsubscribeBlur = navigation.addListener('blur', () => {\n            if (cleanup !== undefined) {\n                cleanup();\n            }\n            cleanup = undefined;\n            isFocused = false;\n        });\n        return () => {\n            if (cleanup !== undefined) {\n                cleanup();\n            }\n            unsubscribeFocus();\n            unsubscribeBlur();\n        };\n    }, [effect, navigation]);\n}\n", "import * as React from 'react';\nimport NavigationContainerRefContext from './NavigationContainerRefContext';\nimport NavigationContext from './NavigationContext';\n/**\n * Hook to access the navigation prop of the parent screen anywhere.\n *\n * @returns Navigation prop of the parent screen.\n */\nexport default function useNavigation() {\n    const root = React.useContext(NavigationContainerRefContext);\n    const navigation = React.useContext(NavigationContext);\n    if (navigation === undefined && root === undefined) {\n        throw new Error(\"Couldn't find a navigation object. Is your component inside NavigationContainer?\");\n    }\n    // FIXME: Figure out a better way to do this\n    return (navigation ?? root);\n}\n", "import * as React from 'react';\nimport { useState } from 'react';\nimport useNavigation from './useNavigation';\n/**\n * Hook to get the current focus state of the screen. Returns a `true` if screen is focused, otherwise `false`.\n * This can be used if a component needs to render something based on the focus state.\n */\nexport default function useIsFocused() {\n    const navigation = useNavigation();\n    const [isFocused, setIsFocused] = useState(navigation.isFocused);\n    const valueToReturn = navigation.isFocused();\n    if (isFocused !== valueToReturn) {\n        // If the value has changed since the last render, we need to update it.\n        // This could happen if we missed an update from the event listeners during re-render.\n        // React will process this update immediately, so the old subscription value won't be committed.\n        // It is still nice to avoid returning a mismatched value though, so let's override the return value.\n        // This is the same logic as in https://github.com/facebook/react/tree/master/packages/use-subscription\n        setIsFocused(valueToReturn);\n    }\n    React.useEffect(() => {\n        const unsubscribeFocus = navigation.addListener('focus', () => setIsFocused(true));\n        const unsubscribeBlur = navigation.addListener('blur', () => setIsFocused(false));\n        return () => {\n            unsubscribeFocus();\n            unsubscribeBlur();\n        };\n    }, [navigation]);\n    React.useDebugValue(valueToReturn);\n    return valueToReturn;\n}\n", "import { CommonActions, } from '@react-navigation/routers';\nimport * as React from 'react';\nimport { isValidElementType } from 'react-is';\nimport Group from './Group';\nimport isArrayEqual from './isArrayEqual';\nimport isRecordEqual from './isRecordEqual';\nimport NavigationHelpersContext from './NavigationHelpersContext';\nimport NavigationRouteContext from './NavigationRouteContext';\nimport NavigationStateContext from './NavigationStateContext';\nimport Screen from './Screen';\nimport { PrivateValueStore, } from './types';\nimport useChildListeners from './useChildListeners';\nimport useComponent from './useComponent';\nimport useCurrentRender from './useCurrentRender';\nimport useDescriptors from './useDescriptors';\nimport useEventEmitter from './useEventEmitter';\nimport useFocusedListenersChildrenAdapter from './useFocusedListenersChildrenAdapter';\nimport useFocusEvents from './useFocusEvents';\nimport useKeyedChildListeners from './useKeyedChildListeners';\nimport useNavigationHelpers from './useNavigationHelpers';\nimport useOnAction from './useOnAction';\nimport useOnGetState from './useOnGetState';\nimport useOnRouteFocus from './useOnRouteFocus';\nimport useRegisterNavigator from './useRegisterNavigator';\nimport useScheduleUpdate from './useScheduleUpdate';\n// This is to make TypeScript compiler happy\n// eslint-disable-next-line babel/no-unused-expressions\nPrivateValueStore;\nconst isValidKey = (key) => key === undefined || (typeof key === 'string' && key !== '');\n/**\n * Extract route config object from React children elements.\n *\n * @param children React Elements to extract the config from.\n */\nconst getRouteConfigsFromChildren = (children, groupKey, groupOptions) => {\n    const configs = React.Children.toArray(children).reduce((acc, child) => {\n        if (React.isValidElement(child)) {\n            if (child.type === Screen) {\n                // We can only extract the config from `Screen` elements\n                // If something else was rendered, it's probably a bug\n                if (!isValidKey(child.props.navigationKey)) {\n                    throw new Error(`Got an invalid 'navigationKey' prop (${JSON.stringify(child.props.navigationKey)}) for the screen '${child.props.name}'. It must be a non-empty string or 'undefined'.`);\n                }\n                acc.push({\n                    keys: [groupKey, child.props.navigationKey],\n                    options: groupOptions,\n                    props: child.props,\n                });\n                return acc;\n            }\n            if (child.type === React.Fragment || child.type === Group) {\n                if (!isValidKey(child.props.navigationKey)) {\n                    throw new Error(`Got an invalid 'navigationKey' prop (${JSON.stringify(child.props.navigationKey)}) for the group. It must be a non-empty string or 'undefined'.`);\n                }\n                // When we encounter a fragment or group, we need to dive into its children to extract the configs\n                // This is handy to conditionally define a group of screens\n                acc.push(...getRouteConfigsFromChildren(child.props.children, child.props.navigationKey, child.type !== Group\n                    ? groupOptions\n                    : groupOptions != null\n                        ? [...groupOptions, child.props.screenOptions]\n                        : [child.props.screenOptions]));\n                return acc;\n            }\n        }\n        throw new Error(`A navigator can only contain 'Screen', 'Group' or 'React.Fragment' as its direct children (found ${React.isValidElement(child)\n            ? `'${typeof child.type === 'string' ? child.type : child.type?.name}'${child.props?.name ? ` for the screen '${child.props.name}'` : ''}`\n            : typeof child === 'object'\n                ? JSON.stringify(child)\n                : `'${String(child)}'`}). To render this component in the navigator, pass it in the 'component' prop to 'Screen'.`);\n    }, []);\n    if (process.env.NODE_ENV !== 'production') {\n        configs.forEach((config) => {\n            const { name, children, component, getComponent } = config.props;\n            if (typeof name !== 'string' || !name) {\n                throw new Error(`Got an invalid name (${JSON.stringify(name)}) for the screen. It must be a non-empty string.`);\n            }\n            if (children != null ||\n                component !== undefined ||\n                getComponent !== undefined) {\n                if (children != null && component !== undefined) {\n                    throw new Error(`Got both 'component' and 'children' props for the screen '${name}'. You must pass only one of them.`);\n                }\n                if (children != null && getComponent !== undefined) {\n                    throw new Error(`Got both 'getComponent' and 'children' props for the screen '${name}'. You must pass only one of them.`);\n                }\n                if (component !== undefined && getComponent !== undefined) {\n                    throw new Error(`Got both 'component' and 'getComponent' props for the screen '${name}'. You must pass only one of them.`);\n                }\n                if (children != null && typeof children !== 'function') {\n                    throw new Error(`Got an invalid value for 'children' prop for the screen '${name}'. It must be a function returning a React Element.`);\n                }\n                if (component !== undefined && !isValidElementType(component)) {\n                    throw new Error(`Got an invalid value for 'component' prop for the screen '${name}'. It must be a valid React Component.`);\n                }\n                if (getComponent !== undefined && typeof getComponent !== 'function') {\n                    throw new Error(`Got an invalid value for 'getComponent' prop for the screen '${name}'. It must be a function returning a React Component.`);\n                }\n                if (typeof component === 'function' && component.name === 'component') {\n                    // Inline anonymous functions passed in the `component` prop will have the name of the prop\n                    // It's relatively safe to assume that it's not a component since it should also have PascalCase name\n                    // We won't catch all scenarios here, but this should catch a good chunk of incorrect use.\n                    console.warn(`Looks like you're passing an inline function for 'component' prop for the screen '${name}' (e.g. component={() => <SomeComponent />}). Passing an inline function will cause the component state to be lost on re-render and cause perf issues since it's re-created every render. You can pass the function as children to 'Screen' instead to achieve the desired behaviour.`);\n                }\n            }\n            else {\n                throw new Error(`Couldn't find a 'component', 'getComponent' or 'children' prop for the screen '${name}'. This can happen if you passed 'undefined'. You likely forgot to export your component from the file it's defined in, or mixed up default import and named import when importing.`);\n            }\n        });\n    }\n    return configs;\n};\n/**\n * Hook for building navigators.\n *\n * @param createRouter Factory method which returns router object.\n * @param options Options object containing `children` and additional options for the router.\n * @returns An object containing `state`, `navigation`, `descriptors` objects.\n */\nexport default function useNavigationBuilder(createRouter, options) {\n    const navigatorKey = useRegisterNavigator();\n    const route = React.useContext(NavigationRouteContext);\n    const { children, screenListeners, ...rest } = options;\n    const { current: router } = React.useRef(createRouter({\n        ...rest,\n        ...(route?.params &&\n            route.params.state == null &&\n            route.params.initial !== false &&\n            typeof route.params.screen === 'string'\n            ? { initialRouteName: route.params.screen }\n            : null),\n    }));\n    const routeConfigs = getRouteConfigsFromChildren(children);\n    const screens = routeConfigs.reduce((acc, config) => {\n        if (config.props.name in acc) {\n            throw new Error(`A navigator cannot contain multiple 'Screen' components with the same name (found duplicate screen named '${config.props.name}')`);\n        }\n        acc[config.props.name] = config;\n        return acc;\n    }, {});\n    const routeNames = routeConfigs.map((config) => config.props.name);\n    const routeKeyList = routeNames.reduce((acc, curr) => {\n        acc[curr] = screens[curr].keys.map((key) => key ?? '').join(':');\n        return acc;\n    }, {});\n    const routeParamList = routeNames.reduce((acc, curr) => {\n        const { initialParams } = screens[curr].props;\n        acc[curr] = initialParams;\n        return acc;\n    }, {});\n    const routeGetIdList = routeNames.reduce((acc, curr) => Object.assign(acc, {\n        [curr]: screens[curr].props.getId,\n    }), {});\n    if (!routeNames.length) {\n        throw new Error(\"Couldn't find any screens for the navigator. Have you defined any screens as its children?\");\n    }\n    const isStateValid = React.useCallback((state) => state.type === undefined || state.type === router.type, [router.type]);\n    const isStateInitialized = React.useCallback((state) => state !== undefined && state.stale === false && isStateValid(state), [isStateValid]);\n    const { state: currentState, getState: getCurrentState, setState: setCurrentState, setKey, getKey, getIsInitial, } = React.useContext(NavigationStateContext);\n    const stateCleanedUp = React.useRef(false);\n    const cleanUpState = React.useCallback(() => {\n        setCurrentState(undefined);\n        stateCleanedUp.current = true;\n    }, [setCurrentState]);\n    const setState = React.useCallback((state) => {\n        if (stateCleanedUp.current) {\n            // State might have been already cleaned up due to unmount\n            // We do not want to expose API allowing to override this\n            // This would lead to old data preservation on main navigator unmount\n            return;\n        }\n        setCurrentState(state);\n    }, [setCurrentState]);\n    const [initializedState, isFirstStateInitialization] = React.useMemo(() => {\n        const initialRouteParamList = routeNames.reduce((acc, curr) => {\n            const { initialParams } = screens[curr].props;\n            const initialParamsFromParams = route?.params?.state == null &&\n                route?.params?.initial !== false &&\n                route?.params?.screen === curr\n                ? route.params.params\n                : undefined;\n            acc[curr] =\n                initialParams !== undefined || initialParamsFromParams !== undefined\n                    ? {\n                        ...initialParams,\n                        ...initialParamsFromParams,\n                    }\n                    : undefined;\n            return acc;\n        }, {});\n        // If the current state isn't initialized on first render, we initialize it\n        // We also need to re-initialize it if the state passed from parent was changed (maybe due to reset)\n        // Otherwise assume that the state was provided as initial state\n        // So we need to rehydrate it to make it usable\n        if ((currentState === undefined || !isStateValid(currentState)) &&\n            route?.params?.state == null) {\n            return [\n                router.getInitialState({\n                    routeNames,\n                    routeParamList: initialRouteParamList,\n                    routeGetIdList,\n                }),\n                true,\n            ];\n        }\n        else {\n            return [\n                router.getRehydratedState(route?.params?.state ?? currentState, {\n                    routeNames,\n                    routeParamList: initialRouteParamList,\n                    routeGetIdList,\n                }),\n                false,\n            ];\n        }\n        // We explicitly don't include routeNames, route.params etc. in the dep list\n        // below. We want to avoid forcing a new state to be calculated in those cases\n        // Instead, we handle changes to these in the nextState code below. Note\n        // that some changes to routeConfigs are explicitly ignored, such as changes\n        // to initialParams\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [currentState, router, isStateValid]);\n    const previousRouteKeyListRef = React.useRef(routeKeyList);\n    React.useEffect(() => {\n        previousRouteKeyListRef.current = routeKeyList;\n    });\n    const previousRouteKeyList = previousRouteKeyListRef.current;\n    let state = \n    // If the state isn't initialized, or stale, use the state we initialized instead\n    // The state won't update until there's a change needed in the state we have initalized locally\n    // So it'll be `undefined` or stale until the first navigation event happens\n    isStateInitialized(currentState)\n        ? currentState\n        : initializedState;\n    let nextState = state;\n    if (!isArrayEqual(state.routeNames, routeNames) ||\n        !isRecordEqual(routeKeyList, previousRouteKeyList)) {\n        // When the list of route names change, the router should handle it to remove invalid routes\n        nextState = router.getStateForRouteNamesChange(state, {\n            routeNames,\n            routeParamList,\n            routeGetIdList,\n            routeKeyChanges: Object.keys(routeKeyList).filter((name) => previousRouteKeyList.hasOwnProperty(name) &&\n                routeKeyList[name] !== previousRouteKeyList[name]),\n        });\n    }\n    const previousNestedParamsRef = React.useRef(route?.params);\n    React.useEffect(() => {\n        previousNestedParamsRef.current = route?.params;\n    }, [route?.params]);\n    if (route?.params) {\n        const previousParams = previousNestedParamsRef.current;\n        let action;\n        if (typeof route.params.state === 'object' &&\n            route.params.state != null &&\n            route.params !== previousParams) {\n            // If the route was updated with new state, we should reset to it\n            action = CommonActions.reset(route.params.state);\n        }\n        else if (typeof route.params.screen === 'string' &&\n            ((route.params.initial === false && isFirstStateInitialization) ||\n                route.params !== previousParams)) {\n            // If the route was updated with new screen name and/or params, we should navigate there\n            action = CommonActions.navigate({\n                name: route.params.screen,\n                params: route.params.params,\n                path: route.params.path,\n            });\n        }\n        // The update should be limited to current navigator only, so we call the router manually\n        const updatedState = action\n            ? router.getStateForAction(nextState, action, {\n                routeNames,\n                routeParamList,\n                routeGetIdList,\n            })\n            : null;\n        nextState =\n            updatedState !== null\n                ? router.getRehydratedState(updatedState, {\n                    routeNames,\n                    routeParamList,\n                    routeGetIdList,\n                })\n                : nextState;\n    }\n    const shouldUpdate = state !== nextState;\n    useScheduleUpdate(() => {\n        if (shouldUpdate) {\n            // If the state needs to be updated, we'll schedule an update\n            setState(nextState);\n        }\n    });\n    // The up-to-date state will come in next render, but we don't need to wait for it\n    // We can't use the outdated state since the screens have changed, which will cause error due to mismatched config\n    // So we override the state object we return to use the latest state as soon as possible\n    state = nextState;\n    React.useEffect(() => {\n        setKey(navigatorKey);\n        if (!getIsInitial()) {\n            // If it's not initial render, we need to update the state\n            // This will make sure that our container gets notifier of state changes due to new mounts\n            // This is necessary for proper screen tracking, URL updates etc.\n            setState(nextState);\n        }\n        return () => {\n            // We need to clean up state for this navigator on unmount\n            // We do it in a timeout because we need to detect if another navigator mounted in the meantime\n            // For example, if another navigator has started rendering, we should skip cleanup\n            // Otherwise, our cleanup step will cleanup state for the other navigator and re-initialize it\n            setTimeout(() => {\n                if (getCurrentState() !== undefined && getKey() === navigatorKey) {\n                    cleanUpState();\n                }\n            }, 0);\n        };\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    // We initialize this ref here to avoid a new getState getting initialized\n    // whenever initializedState changes. We want getState to have access to the\n    // latest initializedState, but don't need it to change when that happens\n    const initializedStateRef = React.useRef();\n    initializedStateRef.current = initializedState;\n    const getState = React.useCallback(() => {\n        const currentState = getCurrentState();\n        return isStateInitialized(currentState)\n            ? currentState\n            : initializedStateRef.current;\n    }, [getCurrentState, isStateInitialized]);\n    const emitter = useEventEmitter((e) => {\n        let routeNames = [];\n        let route;\n        if (e.target) {\n            route = state.routes.find((route) => route.key === e.target);\n            if (route?.name) {\n                routeNames.push(route.name);\n            }\n        }\n        else {\n            route = state.routes[state.index];\n            routeNames.push(...Object.keys(screens).filter((name) => route?.name === name));\n        }\n        if (route == null) {\n            return;\n        }\n        const navigation = descriptors[route.key].navigation;\n        const listeners = []\n            .concat(\n        // Get an array of listeners for all screens + common listeners on navigator\n        ...[\n            screenListeners,\n            ...routeNames.map((name) => {\n                const { listeners } = screens[name].props;\n                return listeners;\n            }),\n        ].map((listeners) => {\n            const map = typeof listeners === 'function'\n                ? listeners({ route: route, navigation })\n                : listeners;\n            return map\n                ? Object.keys(map)\n                    .filter((type) => type === e.type)\n                    .map((type) => map?.[type])\n                : undefined;\n        }))\n            // We don't want same listener to be called multiple times for same event\n            // So we remove any duplicate functions from the array\n            .filter((cb, i, self) => cb && self.lastIndexOf(cb) === i);\n        listeners.forEach((listener) => listener?.(e));\n    });\n    useFocusEvents({ state, emitter });\n    React.useEffect(() => {\n        emitter.emit({ type: 'state', data: { state } });\n    }, [emitter, state]);\n    const { listeners: childListeners, addListener } = useChildListeners();\n    const { keyedListeners, addKeyedListener } = useKeyedChildListeners();\n    const onAction = useOnAction({\n        router,\n        getState,\n        setState,\n        key: route?.key,\n        actionListeners: childListeners.action,\n        beforeRemoveListeners: keyedListeners.beforeRemove,\n        routerConfigOptions: {\n            routeNames,\n            routeParamList,\n            routeGetIdList,\n        },\n        emitter,\n    });\n    const onRouteFocus = useOnRouteFocus({\n        router,\n        key: route?.key,\n        getState,\n        setState,\n    });\n    const navigation = useNavigationHelpers({\n        onAction,\n        getState,\n        emitter,\n        router,\n    });\n    useFocusedListenersChildrenAdapter({\n        navigation,\n        focusedListeners: childListeners.focus,\n    });\n    useOnGetState({\n        getState,\n        getStateListeners: keyedListeners.getState,\n    });\n    const descriptors = useDescriptors({\n        state,\n        screens,\n        navigation,\n        screenOptions: options.screenOptions,\n        defaultScreenOptions: options.defaultScreenOptions,\n        onAction,\n        getState,\n        setState,\n        onRouteFocus,\n        addListener,\n        addKeyedListener,\n        router,\n        // @ts-expect-error: this should have both core and custom events, but too much work right now\n        emitter,\n    });\n    useCurrentRender({\n        state,\n        navigation,\n        descriptors,\n    });\n    const NavigationContent = useComponent(NavigationHelpersContext.Provider, {\n        value: navigation,\n    });\n    return {\n        state,\n        navigation,\n        descriptors,\n        NavigationContent,\n    };\n}\n", "/**\n * Compare two arrays with primitive values as the content.\n * We need to make sure that both values and order match.\n */\nexport default function isArrayEqual(a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (a.length !== b.length) {\n        return false;\n    }\n    return a.every((it, index) => it === b[index]);\n}\n", "/**\n * Compare two records with primitive values as the content.\n */\nexport default function isRecordEqual(a, b) {\n    if (a === b) {\n        return true;\n    }\n    const aKeys = Object.keys(a);\n    const bKeys = Object.keys(b);\n    if (aKeys.length !== bKeys.length) {\n        return false;\n    }\n    return aKeys.every((key) => a[key] === b[key]);\n}\n", "import * as React from 'react';\nexport default function useComponent(Component, props) {\n    const propsRef = React.useRef(props);\n    // Normally refs shouldn't be mutated in render\n    // But we return a component which will be rendered\n    // So it's just for immediate consumption\n    propsRef.current = props;\n    React.useEffect(() => {\n        propsRef.current = null;\n    });\n    return React.useRef((rest) => {\n        const props = propsRef.current;\n        if (props === null) {\n            throw new Error('The returned component must be rendered in the same render phase as the hook.');\n        }\n        // @ts-expect-error: the props should be fine here\n        return <Component {...props} {...rest}/>;\n    }).current;\n}\n", "import * as React from 'react';\nimport CurrentRenderContext from './CurrentRenderContext';\n/**\n * Write the current options, so that server renderer can get current values\n * Mutating values like this is not safe in async mode, but it doesn't apply to SSR\n */\nexport default function useCurrentRender({ state, navigation, descriptors, }) {\n    const current = React.useContext(CurrentRenderContext);\n    if (current && navigation.isFocused()) {\n        current.options = descriptors[state.routes[state.index].key].options;\n    }\n}\n", "import * as React from 'react';\nimport NavigationBuilderContext from './NavigationBuilderContext';\nimport NavigationContext from './NavigationContext';\nimport NavigationRouteContext from './NavigationRouteContext';\nimport SceneView from './SceneView';\nimport useNavigationCache from './useNavigationCache';\nimport useRouteCache from './useRouteCache';\n/**\n * Hook to create descriptor objects for the child routes.\n *\n * A descriptor object provides 3 things:\n * - Helper method to render a screen\n * - Options specified by the screen for the navigator\n * - Navigation object intended for the route\n */\nexport default function useDescriptors({ state, screens, navigation, screenOptions, defaultScreenOptions, onAction, getState, setState, addListener, addKeyedListener, onRouteFocus, router, emitter, }) {\n    const [options, setOptions] = React.useState({});\n    const { onDispatchAction, onOptionsChange, stackRef } = React.useContext(NavigationBuilderContext);\n    const context = React.useMemo(() => ({\n        navigation,\n        onAction,\n        addListener,\n        addKeyedListener,\n        onRouteFocus,\n        onDispatchAction,\n        onOptionsChange,\n        stackRef,\n    }), [\n        navigation,\n        onAction,\n        addListener,\n        addKeyedListener,\n        onRouteFocus,\n        onDispatchAction,\n        onOptionsChange,\n        stackRef,\n    ]);\n    const navigations = useNavigationCache({\n        state,\n        getState,\n        navigation,\n        setOptions,\n        router,\n        emitter,\n    });\n    const routes = useRouteCache(state.routes);\n    return routes.reduce((acc, route, i) => {\n        const config = screens[route.name];\n        const screen = config.props;\n        const navigation = navigations[route.key];\n        const optionsList = [\n            // The default `screenOptions` passed to the navigator\n            screenOptions,\n            // The `screenOptions` props passed to `Group` elements\n            ...(config.options\n                ? config.options.filter(Boolean)\n                : []),\n            // The `options` prop passed to `Screen` elements,\n            screen.options,\n            // The options set via `navigation.setOptions`\n            options[route.key],\n        ];\n        const customOptions = optionsList.reduce((acc, curr) => Object.assign(acc, typeof curr !== 'function' ? curr : curr({ route, navigation })), {});\n        const mergedOptions = {\n            ...(typeof defaultScreenOptions === 'function'\n                ? // @ts-expect-error: ts gives incorrect error here\n                    defaultScreenOptions({\n                        route,\n                        navigation,\n                        options: customOptions,\n                    })\n                : defaultScreenOptions),\n            ...customOptions,\n        };\n        const clearOptions = () => setOptions((o) => {\n            if (route.key in o) {\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                const { [route.key]: _, ...rest } = o;\n                return rest;\n            }\n            return o;\n        });\n        acc[route.key] = {\n            route,\n            // @ts-expect-error: it's missing action helpers, fix later\n            navigation,\n            render() {\n                return (<NavigationBuilderContext.Provider key={route.key} value={context}>\n            <NavigationContext.Provider value={navigation}>\n              <NavigationRouteContext.Provider value={route}>\n                <SceneView navigation={navigation} route={route} screen={screen} routeState={state.routes[i].state} getState={getState} setState={setState} options={mergedOptions} clearOptions={clearOptions}/>\n              </NavigationRouteContext.Provider>\n            </NavigationContext.Provider>\n          </NavigationBuilderContext.Provider>);\n            },\n            options: mergedOptions,\n        };\n        return acc;\n    }, {});\n}\n", "import * as React from 'react';\nimport EnsureSingleNavigator from './EnsureSingleNavigator';\nimport NavigationStateContext from './NavigationStateContext';\nimport StaticContainer from './StaticContainer';\nimport useOptionsGetters from './useOptionsGetters';\n/**\n * Component which takes care of rendering the screen for a route.\n * It provides all required contexts and applies optimizations when applicable.\n */\nexport default function SceneView({ screen, route, navigation, routeState, getState, setState, options, clearOptions, }) {\n    const navigatorKeyRef = React.useRef();\n    const getKey = React.useCallback(() => navigatorKeyRef.current, []);\n    const { addOptionsGetter } = useOptionsGetters({\n        key: route.key,\n        options,\n        navigation,\n    });\n    const setKey = React.useCallback((key) => {\n        navigatorKeyRef.current = key;\n    }, []);\n    const getCurrentState = React.useCallback(() => {\n        const state = getState();\n        const currentRoute = state.routes.find((r) => r.key === route.key);\n        return currentRoute ? currentRoute.state : undefined;\n    }, [getState, route.key]);\n    const setCurrentState = React.useCallback((child) => {\n        const state = getState();\n        setState({\n            ...state,\n            routes: state.routes.map((r) => r.key === route.key ? { ...r, state: child } : r),\n        });\n    }, [getState, route.key, setState]);\n    const isInitialRef = React.useRef(true);\n    React.useEffect(() => {\n        isInitialRef.current = false;\n    });\n    // Clear options set by this screen when it is unmounted\n    React.useEffect(() => {\n        return clearOptions;\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    const getIsInitial = React.useCallback(() => isInitialRef.current, []);\n    const context = React.useMemo(() => ({\n        state: routeState,\n        getState: getCurrentState,\n        setState: setCurrentState,\n        getKey,\n        setKey,\n        getIsInitial,\n        addOptionsGetter,\n    }), [\n        routeState,\n        getCurrentState,\n        setCurrentState,\n        getKey,\n        setKey,\n        getIsInitial,\n        addOptionsGetter,\n    ]);\n    const ScreenComponent = screen.getComponent\n        ? screen.getComponent()\n        : screen.component;\n    return (<NavigationStateContext.Provider value={context}>\n      <EnsureSingleNavigator>\n        <StaticContainer name={screen.name} render={ScreenComponent || screen.children} navigation={navigation} route={route}>\n          {ScreenComponent !== undefined ? (<ScreenComponent navigation={navigation} route={route}/>) : screen.children !== undefined ? (screen.children({ navigation, route })) : null}\n        </StaticContainer>\n      </EnsureSingleNavigator>\n    </NavigationStateContext.Provider>);\n}\n", "import * as React from 'react';\n/**\n * Component which prevents updates for children if no props changed\n */\nfunction StaticContainer(props) {\n    return props.children;\n}\nexport default React.memo(StaticContainer, (prevProps, nextProps) => {\n    const prevPropKeys = Object.keys(prevProps);\n    const nextPropKeys = Object.keys(nextProps);\n    if (prevPropKeys.length !== nextPropKeys.length) {\n        return false;\n    }\n    for (const key of prevPropKeys) {\n        if (key === 'children') {\n            continue;\n        }\n        if (prevProps[key] !== nextProps[key]) {\n            return false;\n        }\n    }\n    return true;\n});\n", "import { CommonActions, } from '@react-navigation/routers';\nimport * as React from 'react';\nimport NavigationBuilderContext from './NavigationBuilderContext';\n/**\n * Hook to cache navigation objects for each screen in the navigator.\n * It's important to cache them to make sure navigation objects don't change between renders.\n * This lets us apply optimizations like `React.memo` to minimize re-rendering screens.\n */\nexport default function useNavigationCache({ state, getState, navigation, setOptions, router, emitter, }) {\n    const { stackRef } = React.useContext(NavigationBuilderContext);\n    // Cache object which holds navigation objects for each screen\n    // We use `React.useMemo` instead of `React.useRef` coz we want to invalidate it when deps change\n    // In reality, these deps will rarely change, if ever\n    const cache = React.useMemo(() => ({ current: {} }), \n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [getState, navigation, setOptions, router, emitter]);\n    const actions = {\n        ...router.actionCreators,\n        ...CommonActions,\n    };\n    cache.current = state.routes.reduce((acc, route) => {\n        const previous = cache.current[route.key];\n        if (previous) {\n            // If a cached navigation object already exists, reuse it\n            acc[route.key] = previous;\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            const { emit, ...rest } = navigation;\n            const dispatch = (thunk) => {\n                const action = typeof thunk === 'function' ? thunk(getState()) : thunk;\n                if (action != null) {\n                    navigation.dispatch({ source: route.key, ...action });\n                }\n            };\n            const withStack = (callback) => {\n                let isStackSet = false;\n                try {\n                    if (process.env.NODE_ENV !== 'production' &&\n                        stackRef &&\n                        !stackRef.current) {\n                        // Capture the stack trace for devtools\n                        stackRef.current = new Error().stack;\n                        isStackSet = true;\n                    }\n                    callback();\n                }\n                finally {\n                    if (isStackSet && stackRef) {\n                        stackRef.current = undefined;\n                    }\n                }\n            };\n            const helpers = Object.keys(actions).reduce((acc, name) => {\n                acc[name] = (...args) => withStack(() => \n                // @ts-expect-error: name is a valid key, but TypeScript is dumb\n                dispatch(actions[name](...args)));\n                return acc;\n            }, {});\n            acc[route.key] = {\n                ...rest,\n                ...helpers,\n                // FIXME: too much work to fix the types for now\n                ...emitter.create(route.key),\n                dispatch: (thunk) => withStack(() => dispatch(thunk)),\n                setOptions: (options) => setOptions((o) => ({\n                    ...o,\n                    [route.key]: { ...o[route.key], ...options },\n                })),\n                isFocused: () => {\n                    const state = getState();\n                    if (state.routes[state.index].key !== route.key) {\n                        return false;\n                    }\n                    // If the current screen is focused, we also need to check if parent navigator is focused\n                    // This makes sure that we return the focus state in the whole tree, not just this navigator\n                    return navigation ? navigation.isFocused() : true;\n                },\n            };\n        }\n        return acc;\n    }, {});\n    return cache.current;\n}\n", "import * as React from 'react';\nimport NavigationBuilderContext from './NavigationBuilderContext';\n/**\n * Hook for passing focus callback to children\n */\nexport default function useFocusedListenersChildrenAdapter({ navigation, focusedListeners, }) {\n    const { addListener } = React.useContext(NavigationBuilderContext);\n    const listener = React.useCallback((callback) => {\n        if (navigation.isFocused()) {\n            for (const listener of focusedListeners) {\n                const { handled, result } = listener(callback);\n                if (handled) {\n                    return { handled, result };\n                }\n            }\n            return { handled: true, result: callback(navigation) };\n        }\n        else {\n            return { handled: false, result: null };\n        }\n    }, [focusedListeners, navigation]);\n    React.useEffect(() => addListener?.('focus', listener), [addListener, listener]);\n}\n", "import * as React from 'react';\nimport NavigationContext from './NavigationContext';\n/**\n * Hook to take care of emitting `focus` and `blur` events.\n */\nexport default function useFocusEvents({ state, emitter, }) {\n    const navigation = React.useContext(NavigationContext);\n    const lastFocusedKeyRef = React.useRef();\n    const currentFocusedKey = state.routes[state.index].key;\n    // When the parent screen changes its focus state, we also need to change child's focus\n    // Coz the child screen can't be focused if the parent screen is out of focus\n    React.useEffect(() => navigation?.addListener('focus', () => {\n        lastFocusedKeyRef.current = currentFocusedKey;\n        emitter.emit({ type: 'focus', target: currentFocusedKey });\n    }), [currentFocusedKey, emitter, navigation]);\n    React.useEffect(() => navigation?.addListener('blur', () => {\n        lastFocusedKeyRef.current = undefined;\n        emitter.emit({ type: 'blur', target: currentFocusedKey });\n    }), [currentFocusedKey, emitter, navigation]);\n    React.useEffect(() => {\n        const lastFocusedKey = lastFocusedKeyRef.current;\n        lastFocusedKeyRef.current = currentFocusedKey;\n        // We wouldn't have `lastFocusedKey` on initial mount\n        // Fire focus event for the current route on mount if there's no parent navigator\n        if (lastFocusedKey === undefined && !navigation) {\n            emitter.emit({ type: 'focus', target: currentFocusedKey });\n        }\n        // We should only emit events when the focused key changed and navigator is focused\n        // When navigator is not focused, screens inside shouldn't receive focused status either\n        if (lastFocusedKey === currentFocusedKey ||\n            !(navigation ? navigation.isFocused() : true)) {\n            return;\n        }\n        if (lastFocusedKey === undefined) {\n            // Only fire events after initial mount\n            return;\n        }\n        emitter.emit({ type: 'blur', target: lastFocusedKey });\n        emitter.emit({ type: 'focus', target: currentFocusedKey });\n    }, [currentFocusedKey, emitter, navigation]);\n}\n", "import { CommonActions, } from '@react-navigation/routers';\nimport * as React from 'react';\nimport NavigationContext from './NavigationContext';\nimport { PrivateValueStore } from './types';\nimport UnhandledActionContext from './UnhandledActionContext';\n// This is to make TypeScript compiler happy\n// eslint-disable-next-line babel/no-unused-expressions\nPrivateValueStore;\n/**\n * Navigation object with helper methods to be used by a navigator.\n * This object includes methods for common actions as well as methods the parent screen's navigation object.\n */\nexport default function useNavigationHelpers({ onAction, getState, emitter, router }) {\n    const onUnhandledAction = React.useContext(UnhandledActionContext);\n    const parentNavigationHelpers = React.useContext(NavigationContext);\n    return React.useMemo(() => {\n        const dispatch = (op) => {\n            const action = typeof op === 'function' ? op(getState()) : op;\n            const handled = onAction(action);\n            if (!handled) {\n                onUnhandledAction?.(action);\n            }\n        };\n        const actions = {\n            ...router.actionCreators,\n            ...CommonActions,\n        };\n        const helpers = Object.keys(actions).reduce((acc, name) => {\n            // @ts-expect-error: name is a valid key, but TypeScript is dumb\n            acc[name] = (...args) => dispatch(actions[name](...args));\n            return acc;\n        }, {});\n        return {\n            ...parentNavigationHelpers,\n            ...helpers,\n            dispatch,\n            emit: emitter.emit,\n            isFocused: parentNavigationHelpers\n                ? parentNavigationHelpers.isFocused\n                : () => true,\n            canGoBack: () => {\n                const state = getState();\n                return (router.getStateForAction(state, CommonActions.goBack(), {\n                    routeNames: state.routeNames,\n                    routeParamList: {},\n                    routeGetIdList: {},\n                }) !== null ||\n                    parentNavigationHelpers?.canGoBack() ||\n                    false);\n            },\n            getParent: () => parentNavigationHelpers,\n            getState,\n        };\n    }, [\n        emitter.emit,\n        getState,\n        onAction,\n        onUnhandledAction,\n        parentNavigationHelpers,\n        router,\n    ]);\n}\n", "import * as React from 'react';\nimport NavigationBuilderContext from './NavigationBuilderContext';\nimport useOnPreventRemove, { shouldPreventRemove } from './useOnPreventRemove';\n/**\n * Hook to handle actions for a navigator, including state updates and bubbling.\n *\n * Bubbling an action is achieved in 2 ways:\n * 1. To bubble action to parent, we expose the action handler in context and then access the parent context\n * 2. To bubble action to child, child adds event listeners subscribing to actions from parent\n *\n * When the action handler handles as action, it returns `true`, otherwise `false`.\n */\nexport default function useOnAction({ router, getState, setState, key, actionListeners, beforeRemoveListeners, routerConfigOptions, emitter, }) {\n    const { onAction: onActionParent, onRouteFocus: onRouteFocusParent, addListener: addListenerParent, onDispatchAction, } = React.useContext(NavigationBuilderContext);\n    const routerConfigOptionsRef = React.useRef(routerConfigOptions);\n    React.useEffect(() => {\n        routerConfigOptionsRef.current = routerConfigOptions;\n    });\n    const onAction = React.useCallback((action, visitedNavigators = new Set()) => {\n        const state = getState();\n        // Since actions can bubble both up and down, they could come to the same navigator again\n        // We keep track of navigators which have already tried to handle the action and return if it's already visited\n        if (visitedNavigators.has(state.key)) {\n            return false;\n        }\n        visitedNavigators.add(state.key);\n        if (typeof action.target !== 'string' || action.target === state.key) {\n            let result = router.getStateForAction(state, action, routerConfigOptionsRef.current);\n            // If a target is specified and set to current navigator, the action shouldn't bubble\n            // So instead of `null`, we use the state object for such cases to signal that action was handled\n            result =\n                result === null && action.target === state.key ? state : result;\n            if (result !== null) {\n                onDispatchAction(action, state === result);\n                if (state !== result) {\n                    const isPrevented = shouldPreventRemove(emitter, beforeRemoveListeners, state.routes, result.routes, action);\n                    if (isPrevented) {\n                        return true;\n                    }\n                    setState(result);\n                }\n                if (onRouteFocusParent !== undefined) {\n                    // Some actions such as `NAVIGATE` also want to bring the navigated route to focus in the whole tree\n                    // This means we need to focus all of the parent navigators of this navigator as well\n                    const shouldFocus = router.shouldActionChangeFocus(action);\n                    if (shouldFocus && key !== undefined) {\n                        onRouteFocusParent(key);\n                    }\n                }\n                return true;\n            }\n        }\n        if (onActionParent !== undefined) {\n            // Bubble action to the parent if the current navigator didn't handle it\n            if (onActionParent(action, visitedNavigators)) {\n                return true;\n            }\n        }\n        // If the action wasn't handled by current navigator or a parent navigator, let children handle it\n        for (let i = actionListeners.length - 1; i >= 0; i--) {\n            const listener = actionListeners[i];\n            if (listener(action, visitedNavigators)) {\n                return true;\n            }\n        }\n        return false;\n    }, [\n        actionListeners,\n        beforeRemoveListeners,\n        emitter,\n        getState,\n        key,\n        onActionParent,\n        onDispatchAction,\n        onRouteFocusParent,\n        router,\n        setState,\n    ]);\n    useOnPreventRemove({\n        getState,\n        emitter,\n        beforeRemoveListeners,\n    });\n    React.useEffect(() => addListenerParent?.('action', onAction), [addListenerParent, onAction]);\n    return onAction;\n}\n", "import * as React from 'react';\nimport NavigationBuilderContext from './NavigationBuilderContext';\nimport NavigationRouteContext from './NavigationRouteContext';\nconst VISITED_ROUTE_KEYS = Symbol('VISITED_ROUTE_KEYS');\nexport const shouldPreventRemove = (emitter, beforeRemoveListeners, currentRoutes, nextRoutes, action) => {\n    const nextRouteKeys = nextRoutes.map((route) => route.key);\n    // Call these in reverse order so last screens handle the event first\n    const removedRoutes = currentRoutes\n        .filter((route) => !nextRouteKeys.includes(route.key))\n        .reverse();\n    const visitedRouteKeys = \n    // @ts-expect-error: add this property to mark that we've already emitted this action\n    action[VISITED_ROUTE_KEYS] ?? new Set();\n    const beforeRemoveAction = {\n        ...action,\n        [VISITED_ROUTE_KEYS]: visitedRouteKeys,\n    };\n    for (const route of removedRoutes) {\n        if (visitedRouteKeys.has(route.key)) {\n            // Skip if we've already emitted this action for this screen\n            continue;\n        }\n        // First, we need to check if any child screens want to prevent it\n        const isPrevented = beforeRemoveListeners[route.key]?.(beforeRemoveAction);\n        if (isPrevented) {\n            return true;\n        }\n        visitedRouteKeys.add(route.key);\n        const event = emitter.emit({\n            type: 'beforeRemove',\n            target: route.key,\n            data: { action: beforeRemoveAction },\n            canPreventDefault: true,\n        });\n        if (event.defaultPrevented) {\n            return true;\n        }\n    }\n    return false;\n};\nexport default function useOnPreventRemove({ getState, emitter, beforeRemoveListeners, }) {\n    const { addKeyedListener } = React.useContext(NavigationBuilderContext);\n    const route = React.useContext(NavigationRouteContext);\n    const routeKey = route?.key;\n    React.useEffect(() => {\n        if (routeKey) {\n            return addKeyedListener?.('beforeRemove', routeKey, (action) => {\n                const state = getState();\n                return shouldPreventRemove(emitter, beforeRemoveListeners, state.routes, [], action);\n            });\n        }\n    }, [addKeyedListener, beforeRemoveListeners, emitter, getState, routeKey]);\n}\n", "import * as React from 'react';\nimport isArrayEqual from './isArrayEqual';\nimport NavigationBuilderContext from './NavigationBuilderContext';\nimport NavigationRouteContext from './NavigationRouteContext';\nexport default function useOnGetState({ getState, getStateListeners, }) {\n    const { addKeyedListener } = React.useContext(NavigationBuilderContext);\n    const route = React.useContext(NavigationRouteContext);\n    const key = route ? route.key : 'root';\n    const getRehydratedState = React.useCallback(() => {\n        const state = getState();\n        // Avoid returning new route objects if we don't need to\n        const routes = state.routes.map((route) => {\n            const childState = getStateListeners[route.key]?.();\n            if (route.state === childState) {\n                return route;\n            }\n            return { ...route, state: childState };\n        });\n        if (isArrayEqual(state.routes, routes)) {\n            return state;\n        }\n        return { ...state, routes };\n    }, [getState, getStateListeners]);\n    React.useEffect(() => {\n        return addKeyedListener?.('getState', key, getRehydratedState);\n    }, [addKeyedListener, getRehydratedState, key]);\n}\n", "import * as React from 'react';\nimport NavigationBuilderContext from './NavigationBuilderContext';\n/**\n * Hook to handle focus actions for a route.\n * Focus action needs to be treated specially, coz when a nested route is focused,\n * the parent navigators also needs to be focused.\n */\nexport default function useOnRouteFocus({ router, getState, key: sourceRouteKey, setState, }) {\n    const { onRouteFocus: onRouteFocusParent } = React.useContext(NavigationBuilderContext);\n    return React.useCallback((key) => {\n        const state = getState();\n        const result = router.getStateForRouteFocus(state, key);\n        if (result !== state) {\n            setState(result);\n        }\n        if (onRouteFocusParent !== undefined && sourceRouteKey !== undefined) {\n            onRouteFocusParent(sourceRouteKey);\n        }\n    }, [getState, onRouteFocusParent, router, setState, sourceRouteKey]);\n}\n", "import { nanoid } from 'nanoid/non-secure';\nimport * as React from 'react';\nimport { SingleNavigatorContext } from './EnsureSingleNavigator';\n/**\n * Register a navigator in the parent context (either a navigation container or a screen).\n * This is used to prevent multiple navigators under a single container or screen.\n */\nexport default function useRegisterNavigator() {\n    const [key] = React.useState(() => nanoid());\n    const container = React.useContext(SingleNavigatorContext);\n    if (container === undefined) {\n        throw new Error(\"Couldn't register the navigator. Have you wrapped your app with 'NavigationContainer'?\\n\\nThis can also happen if there are multiple copies of '@react-navigation' packages installed.\");\n    }\n    React.useEffect(() => {\n        const { register, unregister } = container;\n        register(key);\n        return () => unregister(key);\n    }, [container, key]);\n    return key;\n}\n", "import * as React from 'react';\nimport createNavigationContainerRef from './createNavigationContainerRef';\nexport default function useNavigationContainerRef() {\n    const navigation = React.useRef(null);\n    if (navigation.current == null) {\n        navigation.current = createNavigationContainerRef();\n    }\n    return navigation.current;\n}\n", "import * as React from 'react';\nimport useNavigation from './useNavigation';\n/**\n * Hook to get a value from the current navigation state using a selector.\n *\n * @param selector Selector function to get a value from the state.\n */\nexport default function useNavigationState(selector) {\n    const navigation = useNavigation();\n    // We don't care about the state value, we run the selector again at the end\n    // The state is only to make sure that there's a re-render when we have a new value\n    const [, setResult] = React.useState(() => selector(navigation.getState()));\n    // We store the selector in a ref to avoid re-subscribing listeners every render\n    const selectorRef = React.useRef(selector);\n    React.useEffect(() => {\n        selectorRef.current = selector;\n    });\n    React.useEffect(() => {\n        const unsubscribe = navigation.addListener('state', (e) => {\n            setResult(selectorRef.current(e.data.state));\n        });\n        return unsubscribe;\n    }, [navigation]);\n    return selector(navigation.getState());\n}\n", "import * as React from 'react';\nimport NavigationRouteContext from './NavigationRouteContext';\n/**\n * Hook to access the route prop of the parent screen anywhere.\n *\n * @returns Route prop of the parent screen.\n */\nexport default function useRoute() {\n    const route = React.useContext(NavigationRouteContext);\n    if (route === undefined) {\n        throw new Error(\"Couldn't find a route object. Is your component inside a screen in a navigator?\");\n    }\n    return route;\n}\n", "export { default as BaseNavigationContainer } from './BaseNavigationContainer';\nexport { default as createNavigationContainerRef } from './createNavigationContainerRef';\nexport { default as createNavigatorFactory } from './createNavigatorFactory';\nexport { default as CurrentRenderContext } from './CurrentRenderContext';\nexport { default as findFocusedRoute } from './findFocusedRoute';\nexport { default as getActionFromState } from './getActionFromState';\nexport { default as getFocusedRouteNameFromRoute } from './getFocusedRouteNameFromRoute';\nexport { default as getPathFromState } from './getPathFromState';\nexport { default as getStateFromPath } from './getStateFromPath';\nexport { default as NavigationContainerRefContext } from './NavigationContainerRefContext';\nexport { default as NavigationContext } from './NavigationContext';\nexport { default as NavigationHelpersContext } from './NavigationHelpersContext';\nexport { default as NavigationRouteContext } from './NavigationRouteContext';\nexport * from './types';\nexport { default as useFocusEffect } from './useFocusEffect';\nexport { default as useIsFocused } from './useIsFocused';\nexport { default as useNavigation } from './useNavigation';\nexport { default as useNavigationBuilder } from './useNavigationBuilder';\nexport { default as useNavigationContainerRef } from './useNavigationContainerRef';\nexport { default as useNavigationState } from './useNavigationState';\nexport { default as useRoute } from './useRoute';\nexport { default as validatePathConfig } from './validatePathConfig';\nexport * from '@react-navigation/routers';\n"],
  "mappings": "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",
  "names": []
}
