{
  "version": 3,
  "sources": ["../../../tmp/@react-navigation/native/src/Link.tsx", "../../../tmp/@react-navigation/native/src/useLinkProps.tsx", "../../../tmp/@react-navigation/native/src/LinkingContext.tsx", "../../../tmp/@react-navigation/native/src/useLinkTo.tsx", "../../../tmp/@react-navigation/native/src/NavigationContainer.tsx", "../../../tmp/@react-navigation/native/src/theming/DefaultTheme.tsx", "../../../tmp/@react-navigation/native/src/theming/ThemeProvider.tsx", "../../../tmp/@react-navigation/native/src/theming/ThemeContext.tsx", "../../../tmp/@react-navigation/native/src/useBackButton.tsx", "../../../tmp/@react-navigation/native/src/useDocumentTitle.tsx", "../../../tmp/@react-navigation/native/src/useLinking.tsx", "../../../tmp/@react-navigation/native/src/ServerContext.tsx", "../../../tmp/@react-navigation/native/src/useThenable.tsx", "../../../tmp/@react-navigation/native/src/ServerContainer.tsx", "../../../tmp/@react-navigation/native/src/theming/DarkTheme.tsx", "../../../tmp/@react-navigation/native/src/theming/useTheme.tsx", "../../../tmp/@react-navigation/native/src/useLinkBuilder.tsx", "../../../tmp/@react-navigation/native/src/useScrollToTop.tsx", "../../../tmp/@react-navigation/native/src/index.tsx"],
  "sourcesContent": ["import * as React from 'react';\nimport { Platform, Text } from 'react-native';\nimport useLinkProps from './useLinkProps';\n/**\n * Component to render link to another screen using a path.\n * Uses an anchor tag on the web.\n *\n * @param props.to Absolute path to screen (e.g. `/feeds/hot`).\n * @param props.action Optional action to use for in-page navigation. By default, the path is parsed to an action based on linking config.\n * @param props.children Child elements to render the content.\n */\nexport default function Link({ to, action, ...rest }) {\n    const props = useLinkProps({ to, action });\n    const onPress = (e) => {\n        if ('onPress' in rest) {\n            rest.onPress?.(e);\n        }\n        props.onPress(e);\n    };\n    return React.createElement(Text, {\n        ...props,\n        ...rest,\n        ...Platform.select({\n            web: { onClick: onPress },\n            default: { onPress },\n        }),\n    });\n}\n", "import { getPathFromState, NavigationContainerRefContext, NavigationHelpersContext, } from '@react-navigation/core';\nimport * as React from 'react';\nimport { Platform } from 'react-native';\nimport LinkingContext from './LinkingContext';\nimport useLinkTo from './useLinkTo';\nconst getStateFromParams = (params) => {\n    if (params?.state) {\n        return params.state;\n    }\n    if (params?.screen) {\n        return {\n            routes: [\n                {\n                    name: params.screen,\n                    params: params.params,\n                    // @ts-expect-error\n                    state: params.screen\n                        ? getStateFromParams(params.params)\n                        : undefined,\n                },\n            ],\n        };\n    }\n    return undefined;\n};\n/**\n * Hook to get props for an anchor tag so it can work with in page navigation.\n *\n * @param props.to Absolute path to screen (e.g. `/feeds/hot`).\n * @param props.action Optional action to use for in-page navigation. By default, the path is parsed to an action based on linking config.\n */\nexport default function useLinkProps({ to, action }) {\n    const root = React.useContext(NavigationContainerRefContext);\n    const navigation = React.useContext(NavigationHelpersContext);\n    const { options } = React.useContext(LinkingContext);\n    const linkTo = useLinkTo();\n    const onPress = (e) => {\n        let shouldHandle = false;\n        if (Platform.OS !== 'web' || !e) {\n            shouldHandle = e ? !e.defaultPrevented : true;\n        }\n        else if (!e.defaultPrevented && // onPress prevented default\n            // @ts-expect-error: these properties exist on web, but not in React Native\n            !(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) && // ignore clicks with modifier keys\n            // @ts-expect-error: these properties exist on web, but not in React Native\n            (e.button == null || e.button === 0) && // ignore everything but left clicks\n            // @ts-expect-error: these properties exist on web, but not in React Native\n            [undefined, null, '', 'self'].includes(e.currentTarget?.target) // let browser handle \"target=_blank\" etc.\n        ) {\n            e.preventDefault();\n            shouldHandle = true;\n        }\n        if (shouldHandle) {\n            if (action) {\n                if (navigation) {\n                    navigation.dispatch(action);\n                }\n                else if (root) {\n                    root.dispatch(action);\n                }\n                else {\n                    throw new Error(\"Couldn't find a navigation object. Is your component inside NavigationContainer?\");\n                }\n            }\n            else {\n                linkTo(to);\n            }\n        }\n    };\n    const getPathFromStateHelper = options?.getPathFromState ?? getPathFromState;\n    const href = typeof to === 'string'\n        ? to\n        : getPathFromStateHelper({\n            routes: [\n                {\n                    name: to.screen,\n                    // @ts-expect-error\n                    params: to.params,\n                    // @ts-expect-error\n                    state: getStateFromParams(to.params),\n                },\n            ],\n        }, options?.config);\n    return {\n        href,\n        accessibilityRole: 'link',\n        onPress,\n    };\n}\n", "import * as React from 'react';\nconst LinkingContext = React.createContext({ options: undefined });\nLinkingContext.displayName = 'LinkingContext';\nexport default LinkingContext;\n", "import { getActionFromState, getStateFromPath, NavigationContainerRefContext, } from '@react-navigation/core';\nimport * as React from 'react';\nimport LinkingContext from './LinkingContext';\nexport default function useLinkTo() {\n    const navigation = React.useContext(NavigationContainerRefContext);\n    const linking = React.useContext(LinkingContext);\n    const linkTo = React.useCallback((to) => {\n        if (navigation === undefined) {\n            throw new Error(\"Couldn't find a navigation object. Is your component inside NavigationContainer?\");\n        }\n        if (typeof to !== 'string') {\n            // @ts-expect-error: This is fine\n            navigation.navigate(to.screen, to.params);\n            return;\n        }\n        if (!to.startsWith('/')) {\n            throw new Error(`The path must start with '/' (${to}).`);\n        }\n        const { options } = linking;\n        const state = options?.getStateFromPath\n            ? options.getStateFromPath(to, options.config)\n            : getStateFromPath(to, options?.config);\n        if (state) {\n            const action = getActionFromState(state, options?.config);\n            if (action !== undefined) {\n                navigation.dispatch(action);\n            }\n            else {\n                navigation.reset(state);\n            }\n        }\n        else {\n            throw new Error('Failed to parse the path to a navigation state.');\n        }\n    }, [linking, navigation]);\n    return linkTo;\n}\n", "import { BaseNavigationContainer, getActionFromState, getPathFromState, getStateFromPath, validatePathConfig, } from '@react-navigation/core';\nimport * as React from 'react';\nimport LinkingContext from './LinkingContext';\nimport DefaultTheme from './theming/DefaultTheme';\nimport ThemeProvider from './theming/ThemeProvider';\nimport useBackButton from './useBackButton';\nimport useDocumentTitle from './useDocumentTitle';\nimport useLinking from './useLinking';\nimport useThenable from './useThenable';\nglobal.REACT_NAVIGATION_DEVTOOLS = new WeakMap();\n/**\n * Container component which holds the navigation state designed for React Native apps.\n * This should be rendered at the root wrapping the whole app.\n *\n * @param props.initialState Initial state object for the navigation tree. When deep link handling is enabled, this will override deep links when specified. Make sure that you don't specify an `initialState` when there's a deep link (`Linking.getInitialURL()`).\n * @param props.onReady Callback which is called after the navigation tree mounts.\n * @param props.onStateChange Callback which is called with the latest navigation state when it changes.\n * @param props.theme Theme object for the navigators.\n * @param props.linking Options for deep linking. Deep link handling is enabled when this prop is provided, unless `linking.enabled` is `false`.\n * @param props.fallback Fallback component to render until we have finished getting initial state when linking is enabled. Defaults to `null`.\n * @param props.documentTitle Options to configure the document title on Web. Updating document title is handled by default unless `documentTitle.enabled` is `false`.\n * @param props.children Child elements to render the content.\n * @param props.ref Ref object which refers to the navigation object containing helper methods.\n */\nfunction NavigationContainerInner({ theme = DefaultTheme, linking, fallback = null, documentTitle, onReady, ...rest }, ref) {\n    const isLinkingEnabled = linking ? linking.enabled !== false : false;\n    if (linking?.config) {\n        validatePathConfig(linking.config);\n    }\n    const refContainer = React.useRef(null);\n    useBackButton(refContainer);\n    useDocumentTitle(refContainer, documentTitle);\n    const { getInitialState } = useLinking(refContainer, {\n        independent: rest.independent,\n        enabled: isLinkingEnabled,\n        prefixes: [],\n        ...linking,\n    });\n    // Add additional linking related info to the ref\n    // This will be used by the devtools\n    React.useEffect(() => {\n        if (refContainer.current) {\n            REACT_NAVIGATION_DEVTOOLS.set(refContainer.current, {\n                get linking() {\n                    return {\n                        ...linking,\n                        enabled: isLinkingEnabled,\n                        prefixes: linking?.prefixes ?? [],\n                        getStateFromPath: linking?.getStateFromPath ?? getStateFromPath,\n                        getPathFromState: linking?.getPathFromState ?? getPathFromState,\n                        getActionFromState: linking?.getActionFromState ?? getActionFromState,\n                    };\n                },\n            });\n        }\n    });\n    const [isResolved, initialState] = useThenable(getInitialState);\n    React.useImperativeHandle(ref, () => refContainer.current);\n    const linkingContext = React.useMemo(() => ({ options: linking }), [linking]);\n    const isReady = rest.initialState != null || !isLinkingEnabled || isResolved;\n    const onReadyRef = React.useRef(onReady);\n    React.useEffect(() => {\n        onReadyRef.current = onReady;\n    });\n    React.useEffect(() => {\n        if (isReady) {\n            onReadyRef.current?.();\n        }\n    }, [isReady]);\n    if (!isReady) {\n        // This is temporary until we have Suspense for data-fetching\n        // Then the fallback will be handled by a parent `Suspense` component\n        return fallback;\n    }\n    return (<LinkingContext.Provider value={linkingContext}>\n      <ThemeProvider value={theme}>\n        <BaseNavigationContainer {...rest} initialState={rest.initialState == null ? initialState : rest.initialState} ref={refContainer}/>\n      </ThemeProvider>\n    </LinkingContext.Provider>);\n}\nconst NavigationContainer = React.forwardRef(NavigationContainerInner);\nexport default NavigationContainer;\n", "const DefaultTheme = {\n    dark: false,\n    colors: {\n        primary: 'rgb(0, 122, 255)',\n        background: 'rgb(242, 242, 242)',\n        card: 'rgb(255, 255, 255)',\n        text: 'rgb(28, 28, 30)',\n        border: 'rgb(216, 216, 216)',\n        notification: 'rgb(255, 59, 48)',\n    },\n};\nexport default DefaultTheme;\n", "import * as React from 'react';\nimport ThemeContext from './ThemeContext';\nexport default function ThemeProvider({ value, children }) {\n    return (<ThemeContext.Provider value={value}>{children}</ThemeContext.Provider>);\n}\n", "import * as React from 'react';\nimport DefaultTheme from './DefaultTheme';\nconst ThemeContext = React.createContext(DefaultTheme);\nThemeContext.displayName = 'ThemeContext';\nexport default ThemeContext;\n", "import * as React from 'react';\nimport { BackHandler } from 'react-native';\nexport default function useBackButton(ref) {\n    React.useEffect(() => {\n        const subscription = BackHandler.addEventListener('hardwareBackPress', () => {\n            const navigation = ref.current;\n            if (navigation == null) {\n                return false;\n            }\n            if (navigation.canGoBack()) {\n                navigation.goBack();\n                return true;\n            }\n            return false;\n        });\n        return () => subscription.remove();\n    }, [ref]);\n}\n", "import * as React from 'react';\n/**\n * Set the document title for the active screen\n */\nexport default function useDocumentTitle(ref, { enabled = true, formatter = (options, route) => options?.title ?? route?.name, } = {}) {\n    React.useEffect(() => {\n        if (!enabled) {\n            return;\n        }\n        const navigation = ref.current;\n        if (navigation) {\n            const title = formatter(navigation.getCurrentOptions(), navigation.getCurrentRoute());\n            document.title = title;\n        }\n        return navigation?.addListener('options', (e) => {\n            const title = formatter(e.data.options, navigation?.getCurrentRoute());\n            document.title = title;\n        });\n    });\n}\n", "import { findFocusedRoute, getActionFromState as getActionFromStateDefault, getPathFromState as getPathFromStateDefault, getStateFromPath as getStateFromPathDefault, } from '@react-navigation/core';\nimport { nanoid } from 'nanoid/non-secure';\nimport * as React from 'react';\nimport ServerContext from './ServerContext';\nconst createMemoryHistory = () => {\n    let index = 0;\n    let items = [];\n    // Pending callbacks for `history.go(n)`\n    // We might modify the callback stored if it was interrupted, so we have a ref to identify it\n    const pending = [];\n    const interrupt = () => {\n        // If another history operation was performed we need to interrupt existing ones\n        // This makes sure that calls such as `history.replace` after `history.go` don't happen\n        // Since otherwise it won't be correct if something else has changed\n        pending.forEach((it) => {\n            const cb = it.cb;\n            it.cb = () => cb(true);\n        });\n    };\n    const history = {\n        get index() {\n            // We store an id in the state instead of an index\n            // Index could get out of sync with in-memory values if page reloads\n            const id = window.history.state?.id;\n            if (id) {\n                const index = items.findIndex((item) => item.id === id);\n                return index > -1 ? index : 0;\n            }\n            return 0;\n        },\n        get(index) {\n            return items[index];\n        },\n        backIndex({ path }) {\n            // We need to find the index from the element before current to get closest path to go back to\n            for (let i = index - 1; i >= 0; i--) {\n                const item = items[i];\n                if (item.path === path) {\n                    return i;\n                }\n            }\n            return -1;\n        },\n        push({ path, state }) {\n            interrupt();\n            const id = nanoid();\n            // When a new entry is pushed, all the existing entries after index will be inaccessible\n            // So we remove any existing entries after the current index to clean them up\n            items = items.slice(0, index + 1);\n            items.push({ path, state, id });\n            index = items.length - 1;\n            // We pass empty string for title because it's ignored in all browsers except safari\n            // We don't store state object in history.state because:\n            // - browsers have limits on how big it can be, and we don't control the size\n            // - while not recommended, there could be non-serializable data in state\n            window.history.pushState({ id }, '', path);\n        },\n        replace({ path, state }) {\n            interrupt();\n            const id = window.history.state?.id ?? nanoid();\n            if (!items.length || items.findIndex((item) => item.id === id) < 0) {\n                // There are two scenarios for creating an array with only one history record:\n                // - When loaded id not found in the items array, this function by default will replace\n                //   the first item. We need to keep only the new updated object, otherwise it will break\n                //   the page when navigating forward in history.\n                // - This is the first time any state modifications are done\n                //   So we need to push the entry as there's nothing to replace\n                items = [{ path, state, id }];\n            }\n            else {\n                items[index] = { path, state, id };\n            }\n            window.history.replaceState({ id }, '', path);\n        },\n        // `history.go(n)` is asynchronous, there are couple of things to keep in mind:\n        // - it won't do anything if we can't go `n` steps, the `popstate` event won't fire.\n        // - each `history.go(n)` call will trigger a separate `popstate` event with correct location.\n        // - the `popstate` event fires before the next frame after calling `history.go(n)`.\n        // This method differs from `history.go(n)` in the sense that it'll go back as many steps it can.\n        go(n) {\n            interrupt();\n            if (n > 0) {\n                // We shouldn't go forward more than available index\n                n = Math.min(n, items.length - 1);\n            }\n            else if (n < 0) {\n                // We shouldn't go back more than the 0 index\n                // Otherwise we'll exit the page\n                n = index + n < 0 ? -index : n;\n            }\n            if (n === 0) {\n                return;\n            }\n            index += n;\n            // When we call `history.go`, `popstate` will fire when there's history to go back to\n            // So we need to somehow handle following cases:\n            // - There's history to go back, `history.go` is called, and `popstate` fires\n            // - `history.go` is called multiple times, we need to resolve on respective `popstate`\n            // - No history to go back, but `history.go` was called, browser has no API to detect it\n            return new Promise((resolve, reject) => {\n                const done = (interrupted) => {\n                    clearTimeout(timer);\n                    if (interrupted) {\n                        reject(new Error('History was changed during navigation.'));\n                        return;\n                    }\n                    // There seems to be a bug in Chrome regarding updating the title\n                    // If we set a title just before calling `history.go`, the title gets lost\n                    // However the value of `document.title` is still what we set it to\n                    // It's just not displayed in the tab bar\n                    // To update the tab bar, we need to reset the title to something else first (e.g. '')\n                    // And set the title to what it was before so it gets applied\n                    // It won't work without setting it to empty string coz otherwise title isn't changing\n                    // Which means that the browser won't do anything after setting the title\n                    const { title } = window.document;\n                    window.document.title = '';\n                    window.document.title = title;\n                    resolve();\n                };\n                pending.push({ ref: done, cb: done });\n                // If navigation didn't happen within 100ms, assume that it won't happen\n                // This may not be accurate, but hopefully it won't take so much time\n                // In Chrome, navigation seems to happen instantly in next microtask\n                // But on Firefox, it seems to take much longer, around 50ms from our testing\n                // We're using a hacky timeout since there doesn't seem to be way to know for sure\n                const timer = setTimeout(() => {\n                    const index = pending.findIndex((it) => it.ref === done);\n                    if (index > -1) {\n                        pending[index].cb();\n                        pending.splice(index, 1);\n                    }\n                }, 100);\n                const onPopState = () => {\n                    const id = window.history.state?.id;\n                    const currentIndex = items.findIndex((item) => item.id === id);\n                    // Fix createMemoryHistory.index variable's value\n                    // as it may go out of sync when navigating in the browser.\n                    index = Math.max(currentIndex, 0);\n                    const last = pending.pop();\n                    window.removeEventListener('popstate', onPopState);\n                    last?.cb();\n                };\n                window.addEventListener('popstate', onPopState);\n                window.history.go(n);\n            });\n        },\n        // The `popstate` event is triggered when history changes, except `pushState` and `replaceState`\n        // If we call `history.go(n)` ourselves, we don't want it to trigger the listener\n        // Here we normalize it so that only external changes (e.g. user pressing back/forward) trigger the listener\n        listen(listener) {\n            const onPopState = () => {\n                if (pending.length) {\n                    // This was triggered by `history.go(n)`, we shouldn't call the listener\n                    return;\n                }\n                listener();\n            };\n            window.addEventListener('popstate', onPopState);\n            return () => window.removeEventListener('popstate', onPopState);\n        },\n    };\n    return history;\n};\n/**\n * Find the matching navigation state that changed between 2 navigation states\n * e.g.: a -> b -> c -> d and a -> b -> c -> e -> f, if history in b changed, b is the matching state\n */\nconst findMatchingState = (a, b) => {\n    if (a === undefined || b === undefined || a.key !== b.key) {\n        return [undefined, undefined];\n    }\n    // Tab and drawer will have `history` property, but stack will have history in `routes`\n    const aHistoryLength = a.history ? a.history.length : a.routes.length;\n    const bHistoryLength = b.history ? b.history.length : b.routes.length;\n    const aRoute = a.routes[a.index];\n    const bRoute = b.routes[b.index];\n    const aChildState = aRoute.state;\n    const bChildState = bRoute.state;\n    // Stop here if this is the state object that changed:\n    // - history length is different\n    // - focused routes are different\n    // - one of them doesn't have child state\n    // - child state keys are different\n    if (aHistoryLength !== bHistoryLength ||\n        aRoute.key !== bRoute.key ||\n        aChildState === undefined ||\n        bChildState === undefined ||\n        aChildState.key !== bChildState.key) {\n        return [a, b];\n    }\n    return findMatchingState(aChildState, bChildState);\n};\n/**\n * Run async function in series as it's called.\n */\nconst series = (cb) => {\n    // Whether we're currently handling a callback\n    let handling = false;\n    let queue = [];\n    const callback = async () => {\n        try {\n            if (handling) {\n                // If we're currently handling a previous event, wait before handling this one\n                // Add the callback to the beginning of the queue\n                queue.unshift(callback);\n                return;\n            }\n            handling = true;\n            await cb();\n        }\n        finally {\n            handling = false;\n            if (queue.length) {\n                // If we have queued items, handle the last one\n                const last = queue.pop();\n                last?.();\n            }\n        }\n    };\n    return callback;\n};\nlet linkingHandlers = [];\nexport default function useLinking(ref, { independent, enabled = true, config, getStateFromPath = getStateFromPathDefault, getPathFromState = getPathFromStateDefault, getActionFromState = getActionFromStateDefault, }) {\n    React.useEffect(() => {\n        if (process.env.NODE_ENV === 'production') {\n            return undefined;\n        }\n        if (independent) {\n            return undefined;\n        }\n        if (enabled !== false && linkingHandlers.length) {\n            console.error([\n                'Looks like you have configured linking in multiple places. This is likely an error since deep links should only be handled in one place to avoid conflicts. Make sure that:',\n                \"- You don't have multiple NavigationContainers in the app each with 'linking' enabled\",\n                '- Only a single instance of the root component is rendered',\n            ]\n                .join('\\n')\n                .trim());\n        }\n        const handler = Symbol();\n        if (enabled !== false) {\n            linkingHandlers.push(handler);\n        }\n        return () => {\n            const index = linkingHandlers.indexOf(handler);\n            if (index > -1) {\n                linkingHandlers.splice(index, 1);\n            }\n        };\n    }, [enabled, independent]);\n    const [history] = React.useState(createMemoryHistory);\n    // We store these options in ref to avoid re-creating getInitialState and re-subscribing listeners\n    // This lets user avoid wrapping the items in `React.useCallback` or `React.useMemo`\n    // Not re-creating `getInitialState` is important coz it makes it easier for the user to use in an effect\n    const enabledRef = React.useRef(enabled);\n    const configRef = React.useRef(config);\n    const getStateFromPathRef = React.useRef(getStateFromPath);\n    const getPathFromStateRef = React.useRef(getPathFromState);\n    const getActionFromStateRef = React.useRef(getActionFromState);\n    React.useEffect(() => {\n        enabledRef.current = enabled;\n        configRef.current = config;\n        getStateFromPathRef.current = getStateFromPath;\n        getPathFromStateRef.current = getPathFromState;\n        getActionFromStateRef.current = getActionFromState;\n    });\n    const server = React.useContext(ServerContext);\n    const getInitialState = React.useCallback(() => {\n        let value;\n        if (enabledRef.current) {\n            const location = server?.location ??\n                (typeof window !== 'undefined' ? window.location : undefined);\n            const path = location ? location.pathname + location.search : undefined;\n            if (path) {\n                value = getStateFromPathRef.current(path, configRef.current);\n            }\n        }\n        const thenable = {\n            then(onfulfilled) {\n                return Promise.resolve(onfulfilled ? onfulfilled(value) : value);\n            },\n            catch() {\n                return thenable;\n            },\n        };\n        return thenable;\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    const previousIndexRef = React.useRef(undefined);\n    const previousStateRef = React.useRef(undefined);\n    const pendingPopStatePathRef = React.useRef(undefined);\n    React.useEffect(() => {\n        previousIndexRef.current = history.index;\n        return history.listen(() => {\n            const navigation = ref.current;\n            if (!navigation || !enabled) {\n                return;\n            }\n            const path = location.pathname + location.search;\n            const index = history.index;\n            const previousIndex = previousIndexRef.current ?? 0;\n            previousIndexRef.current = index;\n            pendingPopStatePathRef.current = path;\n            // When browser back/forward is clicked, we first need to check if state object for this index exists\n            // If it does we'll reset to that state object\n            // Otherwise, we'll handle it like a regular deep link\n            const record = history.get(index);\n            if (record?.path === path && record?.state) {\n                navigation.resetRoot(record.state);\n                return;\n            }\n            const state = getStateFromPathRef.current(path, configRef.current);\n            // We should only dispatch an action when going forward\n            // Otherwise the action will likely add items to history, which would mess things up\n            if (state) {\n                // Make sure that the routes in the state exist in the root navigator\n                // Otherwise there's an error in the linking configuration\n                const rootState = navigation.getRootState();\n                if (state.routes.some((r) => !rootState?.routeNames.includes(r.name))) {\n                    console.warn(\"The navigation state parsed from the URL contains routes not present in the root navigator. This usually means that the linking configuration doesn't match the navigation structure. See https://reactnavigation.org/docs/configuring-links for more details on how to specify a linking configuration.\");\n                    return;\n                }\n                if (index > previousIndex) {\n                    const action = getActionFromStateRef.current(state, configRef.current);\n                    if (action !== undefined) {\n                        try {\n                            navigation.dispatch(action);\n                        }\n                        catch (e) {\n                            // Ignore any errors from deep linking.\n                            // This could happen in case of malformed links, navigation object not being initialized etc.\n                            console.warn(`An error occurred when trying to handle the link '${path}': ${e.message}`);\n                        }\n                    }\n                    else {\n                        navigation.resetRoot(state);\n                    }\n                }\n                else {\n                    navigation.resetRoot(state);\n                }\n            }\n            else {\n                // if current path didn't return any state, we should revert to initial state\n                navigation.resetRoot(state);\n            }\n        });\n    }, [enabled, history, ref]);\n    React.useEffect(() => {\n        if (!enabled) {\n            return;\n        }\n        if (ref.current) {\n            // We need to record the current metadata on the first render if they aren't set\n            // This will allow the initial state to be in the history entry\n            const state = ref.current.getRootState();\n            if (state) {\n                const route = findFocusedRoute(state);\n                const path = route?.path ?? getPathFromStateRef.current(state, configRef.current);\n                if (previousStateRef.current === undefined) {\n                    previousStateRef.current = state;\n                }\n                history.replace({ path, state });\n            }\n        }\n        const onStateChange = async () => {\n            const navigation = ref.current;\n            if (!navigation || !enabled) {\n                return;\n            }\n            const previousState = previousStateRef.current;\n            const state = navigation.getRootState();\n            const pendingPath = pendingPopStatePathRef.current;\n            const route = findFocusedRoute(state);\n            const path = route?.path ?? getPathFromStateRef.current(state, configRef.current);\n            previousStateRef.current = state;\n            pendingPopStatePathRef.current = undefined;\n            // To detect the kind of state change, we need to:\n            // - Find the common focused navigation state in previous and current state\n            // - If only the route keys changed, compare history/routes.length to check if we go back/forward/replace\n            // - If no common focused navigation state found, it's a replace\n            const [previousFocusedState, focusedState] = findMatchingState(previousState, state);\n            if (previousFocusedState &&\n                focusedState &&\n                // We should only handle push/pop if path changed from what was in last `popstate`\n                // Otherwise it's likely a change triggered by `popstate`\n                path !== pendingPath) {\n                const historyDelta = (focusedState.history\n                    ? focusedState.history.length\n                    : focusedState.routes.length) -\n                    (previousFocusedState.history\n                        ? previousFocusedState.history.length\n                        : previousFocusedState.routes.length);\n                if (historyDelta > 0) {\n                    // If history length is increased, we should pushState\n                    // Note that path might not actually change here, for example, drawer open should pushState\n                    history.push({ path, state });\n                }\n                else if (historyDelta < 0) {\n                    // If history length is decreased, i.e. entries were removed, we want to go back\n                    const nextIndex = history.backIndex({ path });\n                    const currentIndex = history.index;\n                    try {\n                        if (nextIndex !== -1 && nextIndex < currentIndex) {\n                            // An existing entry for this path exists and it's less than current index, go back to that\n                            await history.go(nextIndex - currentIndex);\n                        }\n                        else {\n                            // We couldn't find an existing entry to go back to, so we'll go back by the delta\n                            // This won't be correct if multiple routes were pushed in one go before\n                            // Usually this shouldn't happen and this is a fallback for that\n                            await history.go(historyDelta);\n                        }\n                        // Store the updated state as well as fix the path if incorrect\n                        history.replace({ path, state });\n                    }\n                    catch (e) {\n                        // The navigation was interrupted\n                    }\n                }\n                else {\n                    // If history length is unchanged, we want to replaceState\n                    history.replace({ path, state });\n                }\n            }\n            else {\n                // If no common navigation state was found, assume it's a replace\n                // This would happen if the user did a reset/conditionally changed navigators\n                history.replace({ path, state });\n            }\n        };\n        // We debounce onStateChange coz we don't want multiple state changes to be handled at one time\n        // This could happen since `history.go(n)` is asynchronous\n        // If `pushState` or `replaceState` were called before `history.go(n)` completes, it'll mess stuff up\n        return ref.current?.addListener('state', series(onStateChange));\n    });\n    return {\n        getInitialState,\n    };\n}\n", "import * as React from 'react';\nconst ServerContext = React.createContext(undefined);\nexport default ServerContext;\n", "import * as React from 'react';\nexport default function useThenable(create) {\n    const [promise] = React.useState(create);\n    let initialState = [false, undefined];\n    // Check if our thenable is synchronous\n    promise.then((result) => {\n        initialState = [true, result];\n    });\n    const [state, setState] = React.useState(initialState);\n    const [resolved] = state;\n    React.useEffect(() => {\n        let cancelled = false;\n        const resolve = async () => {\n            let result;\n            try {\n                result = await promise;\n            }\n            finally {\n                if (!cancelled) {\n                    setState([true, result]);\n                }\n            }\n        };\n        if (!resolved) {\n            resolve();\n        }\n        return () => {\n            cancelled = true;\n        };\n    }, [promise, resolved]);\n    return state;\n}\n", "import { CurrentRenderContext } from '@react-navigation/core';\nimport * as React from 'react';\nimport ServerContext from './ServerContext';\n/**\n * Container component for server rendering.\n *\n * @param props.location Location object to base the initial URL for SSR.\n * @param props.children Child elements to render the content.\n * @param props.ref Ref object which contains helper methods.\n */\nexport default React.forwardRef(function ServerContainer({ children, location }, ref) {\n    React.useEffect(() => {\n        console.error(\"'ServerContainer' should only be used on the server with 'react-dom/server' for SSR.\");\n    }, []);\n    const current = {};\n    if (ref) {\n        const value = {\n            getCurrentOptions() {\n                return current.options;\n            },\n        };\n        // We write to the `ref` during render instead of `React.useImperativeHandle`\n        // This is because `useImperativeHandle` will update the ref after 'commit',\n        // and there's no 'commit' phase during SSR.\n        // Mutating ref during render is unsafe in concurrent mode, but we don't care about it for SSR.\n        if (typeof ref === 'function') {\n            ref(value);\n        }\n        else {\n            // @ts-expect-error: the TS types are incorrect and say that ref.current is readonly\n            ref.current = value;\n        }\n    }\n    return (<ServerContext.Provider value={{ location }}>\n      <CurrentRenderContext.Provider value={current}>\n        {children}\n      </CurrentRenderContext.Provider>\n    </ServerContext.Provider>);\n});\n", "const DarkTheme = {\n    dark: true,\n    colors: {\n        primary: 'rgb(10, 132, 255)',\n        background: 'rgb(1, 1, 1)',\n        card: 'rgb(18, 18, 18)',\n        text: 'rgb(229, 229, 231)',\n        border: 'rgb(39, 39, 41)',\n        notification: 'rgb(255, 69, 58)',\n    },\n};\nexport default DarkTheme;\n", "import * as React from 'react';\nimport ThemeContext from './ThemeContext';\nexport default function useTheme() {\n    const theme = React.useContext(ThemeContext);\n    return theme;\n}\n", "import { getPathFromState, NavigationHelpersContext, } from '@react-navigation/core';\nimport * as React from 'react';\nimport LinkingContext from './LinkingContext';\nconst getRootStateForNavigate = (navigation, state) => {\n    const parent = navigation.getParent();\n    if (parent) {\n        const parentState = parent.getState();\n        return getRootStateForNavigate(parent, {\n            index: 0,\n            routes: [\n                {\n                    ...parentState.routes[parentState.index],\n                    state: state,\n                },\n            ],\n        });\n    }\n    return state;\n};\n/**\n * Build destination link for a navigate action.\n * Useful for showing anchor tags on the web for buttons that perform navigation.\n */\nexport default function useLinkBuilder() {\n    const navigation = React.useContext(NavigationHelpersContext);\n    const linking = React.useContext(LinkingContext);\n    const buildLink = React.useCallback((name, params) => {\n        const { options } = linking;\n        if (options?.enabled === false) {\n            return undefined;\n        }\n        const state = navigation\n            ? getRootStateForNavigate(navigation, {\n                index: 0,\n                routes: [{ name, params }],\n            })\n            : // If we couldn't find a navigation object in context, we're at root\n                // So we'll construct a basic state object to use\n                {\n                    index: 0,\n                    routes: [{ name, params }],\n                };\n        const path = options?.getPathFromState\n            ? options.getPathFromState(state, options?.config)\n            : getPathFromState(state, options?.config);\n        return path;\n    }, [linking, navigation]);\n    return buildLink;\n}\n", "import { useNavigation, useRoute } from '@react-navigation/core';\nimport * as React from 'react';\nfunction getScrollableNode(ref) {\n    if (ref.current == null) {\n        return null;\n    }\n    if ('scrollToTop' in ref.current ||\n        'scrollTo' in ref.current ||\n        'scrollToOffset' in ref.current ||\n        'scrollResponderScrollTo' in ref.current) {\n        // This is already a scrollable node.\n        return ref.current;\n    }\n    else if ('getScrollResponder' in ref.current) {\n        // If the view is a wrapper like FlatList, SectionList etc.\n        // We need to use `getScrollResponder` to get access to the scroll responder\n        return ref.current.getScrollResponder();\n    }\n    else if ('getNode' in ref.current) {\n        // When a `ScrollView` is wraped in `Animated.createAnimatedComponent`\n        // we need to use `getNode` to get the ref to the actual scrollview.\n        // Note that `getNode` is deprecated in newer versions of react-native\n        // this is why we check if we already have a scrollable node above.\n        return ref.current.getNode();\n    }\n    else {\n        return ref.current;\n    }\n}\nexport default function useScrollToTop(ref) {\n    const navigation = useNavigation();\n    const route = useRoute();\n    React.useEffect(() => {\n        let current = navigation;\n        // The screen might be inside another navigator such as stack nested in tabs\n        // We need to find the closest tab navigator and add the listener there\n        while (current && current.getState().type !== 'tab') {\n            current = current.getParent();\n        }\n        if (!current) {\n            return;\n        }\n        const unsubscribe = current.addListener(\n        // We don't wanna import tab types here to avoid extra deps\n        // in addition, there are multiple tab implementations\n        // @ts-expect-error\n        'tabPress', (e) => {\n            // We should scroll to top only when the screen is focused\n            const isFocused = navigation.isFocused();\n            // In a nested stack navigator, tab press resets the stack to first screen\n            // So we should scroll to top only when we are on first screen\n            const isFirst = navigation === current ||\n                navigation.getState().routes[0].key === route.key;\n            // Run the operation in the next frame so we're sure all listeners have been run\n            // This is necessary to know if preventDefault() has been called\n            requestAnimationFrame(() => {\n                const scrollable = getScrollableNode(ref);\n                if (isFocused && isFirst && scrollable && !e.defaultPrevented) {\n                    if ('scrollToTop' in scrollable) {\n                        scrollable.scrollToTop();\n                    }\n                    else if ('scrollTo' in scrollable) {\n                        scrollable.scrollTo({ x: 0, y: 0, animated: true });\n                    }\n                    else if ('scrollToOffset' in scrollable) {\n                        scrollable.scrollToOffset({ offset: 0, animated: true });\n                    }\n                    else if ('scrollResponderScrollTo' in scrollable) {\n                        scrollable.scrollResponderScrollTo({ y: 0, animated: true });\n                    }\n                }\n            });\n        });\n        return unsubscribe;\n    }, [navigation, ref, route.key]);\n}\n", "export { default as Link } from './Link';\nexport { default as NavigationContainer } from './NavigationContainer';\nexport { default as ServerContainer } from './ServerContainer';\nexport { default as DarkTheme } from './theming/DarkTheme';\nexport { default as DefaultTheme } from './theming/DefaultTheme';\nexport { default as ThemeProvider } from './theming/ThemeProvider';\nexport { default as useTheme } from './theming/useTheme';\nexport * from './types';\nexport { default as useLinkBuilder } from './useLinkBuilder';\nexport { default as useLinkProps } from './useLinkProps';\nexport { default as useLinkTo } from './useLinkTo';\nexport { default as useScrollToTop } from './useScrollToTop';\nexport * from '@react-navigation/core';\n"],
  "mappings": "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",
  "names": []
}
